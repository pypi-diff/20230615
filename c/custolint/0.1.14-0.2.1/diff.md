# Comparing `tmp/custolint-0.1.14-py3-none-any.whl.zip` & `tmp/custolint-0.2.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,18 +1,19 @@
-Zip file size: 18080 bytes, number of entries: 16
--rw-r--r--  2.0 unx      341 b- defN 23-Apr-30 19:27 custolint/__init__.py
--rw-r--r--  2.0 unx     1043 b- defN 23-Apr-30 19:27 custolint/cli.py
--rw-r--r--  2.0 unx     4466 b- defN 23-Apr-30 19:27 custolint/coverage.py
--rw-r--r--  2.0 unx     1969 b- defN 23-Apr-30 19:27 custolint/env.py
--rw-r--r--  2.0 unx     1623 b- defN 23-Apr-30 19:27 custolint/flake8.py
--rw-r--r--  2.0 unx     6475 b- defN 23-Apr-30 19:27 custolint/generics.py
--rw-r--r--  2.0 unx     5660 b- defN 23-Apr-30 19:27 custolint/git.py
--rw-r--r--  2.0 unx     6061 b- defN 23-Apr-30 19:27 custolint/mypy.py
--rw-r--r--  2.0 unx     2800 b- defN 23-Apr-30 19:27 custolint/pylint.py
--rw-r--r--  2.0 unx     1363 b- defN 23-Apr-30 19:27 custolint/typing.py
--rw-r--r--  2.0 unx     1188 b- defN 23-Apr-30 19:27 custolint-0.1.14.dist-info/LICENSE.rst
--rw-r--r--  2.0 unx     7042 b- defN 23-Apr-30 19:27 custolint-0.1.14.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-30 19:27 custolint-0.1.14.dist-info/WHEEL
--rw-r--r--  2.0 unx       48 b- defN 23-Apr-30 19:27 custolint-0.1.14.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       10 b- defN 23-Apr-30 19:27 custolint-0.1.14.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1257 b- defN 23-Apr-30 19:27 custolint-0.1.14.dist-info/RECORD
-16 files, 41438 bytes uncompressed, 16030 bytes compressed:  61.3%
+Zip file size: 20187 bytes, number of entries: 17
+-rw-r--r--  2.0 unx      265 b- defN 23-Jun-15 08:38 custolint/__init__.py
+-rw-r--r--  2.0 unx     1865 b- defN 23-Jun-15 08:38 custolint/cli.py
+-rw-r--r--  2.0 unx     4710 b- defN 23-Jun-15 08:38 custolint/coverage.py
+-rw-r--r--  2.0 unx     1969 b- defN 23-Jun-15 08:38 custolint/env.py
+-rw-r--r--  2.0 unx     1623 b- defN 23-Jun-15 08:38 custolint/flake8.py
+-rw-r--r--  2.0 unx     6475 b- defN 23-Jun-15 08:38 custolint/generics.py
+-rw-r--r--  2.0 unx     7212 b- defN 23-Jun-15 08:38 custolint/git.py
+-rw-r--r--  2.0 unx     1460 b- defN 23-Jun-15 08:38 custolint/log.py
+-rw-r--r--  2.0 unx     7003 b- defN 23-Jun-15 08:38 custolint/mypy.py
+-rw-r--r--  2.0 unx     4077 b- defN 23-Jun-15 08:38 custolint/pylint.py
+-rw-r--r--  2.0 unx     1363 b- defN 23-Jun-15 08:38 custolint/typing.py
+-rw-r--r--  2.0 unx     1188 b- defN 23-Jun-15 08:38 custolint-0.2.1.dist-info/LICENSE.rst
+-rw-r--r--  2.0 unx     7223 b- defN 23-Jun-15 08:38 custolint-0.2.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-15 08:38 custolint-0.2.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       48 b- defN 23-Jun-15 08:38 custolint-0.2.1.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       10 b- defN 23-Jun-15 08:38 custolint-0.2.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1324 b- defN 23-Jun-15 08:38 custolint-0.2.1.dist-info/RECORD
+17 files, 47907 bytes uncompressed, 18041 bytes compressed:  62.3%
```

## zipnote {}

```diff
@@ -15,35 +15,38 @@
 
 Filename: custolint/generics.py
 Comment: 
 
 Filename: custolint/git.py
 Comment: 
 
+Filename: custolint/log.py
+Comment: 
+
 Filename: custolint/mypy.py
 Comment: 
 
 Filename: custolint/pylint.py
 Comment: 
 
 Filename: custolint/typing.py
 Comment: 
 
-Filename: custolint-0.1.14.dist-info/LICENSE.rst
+Filename: custolint-0.2.1.dist-info/LICENSE.rst
 Comment: 
 
-Filename: custolint-0.1.14.dist-info/METADATA
+Filename: custolint-0.2.1.dist-info/METADATA
 Comment: 
 
-Filename: custolint-0.1.14.dist-info/WHEEL
+Filename: custolint-0.2.1.dist-info/WHEEL
 Comment: 
 
-Filename: custolint-0.1.14.dist-info/entry_points.txt
+Filename: custolint-0.2.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: custolint-0.1.14.dist-info/top_level.txt
+Filename: custolint-0.2.1.dist-info/top_level.txt
 Comment: 
 
-Filename: custolint-0.1.14.dist-info/RECORD
+Filename: custolint-0.2.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## custolint/__init__.py

```diff
@@ -1,14 +1,9 @@
 """
 ... Put here some global configuration or variables.
 
 :py:const:`custolint.VERSION` or :py:const:`custolint.__version__`:
     Current version of "custolint" library.
 """
 import importlib.metadata
-import logging
-
-from . import env
-
-logging.basicConfig(level=env.LOG_LEVEL)
 
 VERSION = __version__ = importlib.metadata.version('custolint')
```

## custolint/cli.py

```diff
@@ -1,42 +1,60 @@
+# pragma: no cover this module will not be covered by the tests,
+# since it is using most of ``click`` external already tested API
 """
 Command line interface API
 """
-import sys
+import logging
 
-from . import coverage, flake8, generics, mypy, pylint
+import click
 
+from . import coverage, flake8, generics, mypy, pylint, env, log
 
-def cli(*args: str) -> None:
-    """
-    CLI entry point
-    """
-    if not args:
-        args = tuple(sys.argv)
+LOG = logging.getLogger(__name__)
 
-    if len(args) < 2:
-        sys.exit("Require one of argument: mypy, pylint, flake8, coverage")
 
-    command = args[1]
-    if command == "mypy":
-        generics.filer_output(mypy.compare_with_main_branch())
-        return
+@click.group()
+def cli() -> None:
+    """Another custom linter layer. See the commands bellow for supported layers."""
 
-    if command == "pylint":
-        generics.filer_output(pylint.compare_with_main_branch())
-        return
+# TODO if there are no changed files stop all and inform about this
+# TODO: in case of debug show the time in the log
+# TODO: make a colored logs
 
-    if command == "flake8":
-        generics.filer_output(flake8.compare_with_main_branch())
-        return
 
-    if command == "coverage":
-        if len(args) < 3:
-            sys.exit('Path for coverage is missing, usually it is `.coverage`')
+@click.option('--log-level')
+@cli.command(name='mypy')
+def _mypy(log_level: str) -> None:
+    log.setup(log_level or env.LOG_LEVEL)
+    LOG.info('---- mypy ------')
+    generics.filer_output(mypy.compare_with_main_branch())
 
-        coverage_file_location = args[2]
-        generics.group_by_email_and_file_name(
-            coverage.compare_with_main_branch(coverage_file_location)
-        )
-        return
 
-    sys.exit(f'The command {command!r} is not implemented')
+@click.option('--log-level')
+@cli.command(name='pylint')
+def _pylint(log_level: str) -> None:
+    log.setup(log_level or env.LOG_LEVEL)
+    click.echo(click.style('---- pylint ------', fg='green'))
+    generics.filer_output(pylint.compare_with_main_branch())
+
+
+@click.option('--log-level')
+@cli.command(name='flake8')
+def _flake8(log_level: str) -> None:
+    log.setup(log_level or env.LOG_LEVEL)
+    click.echo(click.style('---- flake8 ------', fg='green'))
+    generics.filer_output(flake8.compare_with_main_branch())
+
+
+@click.option('--log-level')
+@click.option('--data-file',
+              help="Read coverage data for report generation from this file. "
+                   "Defaults to '.coverage'. [env: COVERAGE_FILE]")
+@cli.command(name='coverage')
+def _coverage(data_file: str, log_level: str) -> None:
+    log.setup(log_level or env.LOG_LEVEL)
+    click.echo(click.style('---- coverage ------', fg='green'))
+
+    coverage_file_location = data_file
+    generics.group_by_email_and_file_name(
+        coverage.compare_with_main_branch(coverage_file_location)
+    )
```

## custolint/coverage.py

```diff
@@ -126,15 +126,20 @@
         # footer
         if coverage_line.startswith('TOTAL '):
             continue
 
         # alike 'care/__init__.py 6 0 0 0 100%'
         if fields[-1] == "100%":
             continue
+        # TODO: find path and name of uncovered function/method and
+        # show it in missing coverage line
+        # do not show twice the same function/method
 
+        # TODO: to move it on top
+        # sort results of diffs as in pycharm
         if len(fields) > 4 and "Missing" not in fields[-1]:
             missing_coverage_lines = "".join(fields[6:]).split(",")
             for missing in missing_coverage_lines:
                 for line in _process_missing_lines(
                     file_name=fields[0],
                     missing=missing,
                     changes=changes
```

## custolint/git.py

```diff
@@ -1,23 +1,24 @@
 """
 API to get the affected code lines by comparing current branch to a target branch.
 """
-from typing import Iterable, Iterator, Tuple, Union, cast
+from typing import Iterable, Iterator, Tuple, Union, cast, Optional
 from collections import defaultdict
 
 import logging
 import re
 import sys
 import json
 
 import bash
 
 from . import env, typing
 
 LOG = logging.getLogger(__name__)
+MINIMUM_GIT_RECOMMEND_VERSION = (2, 39, 2)
 
 
 def _autodetect_main_branch() -> str:
     """
     Autodetect main/default branch name.
 
     .. important: autodetect can ve override with :py:const:`custolint.env.BRANCH_ENV` os ENV.
@@ -96,38 +97,94 @@
 
     if affected_lines.endswith(",0"):  # the line is deleted and have to be ignored
         return None
 
     return _blame(affected_lines, file_name)
 
 
-def changes() -> typing.Changes:
+def _current_branch_name() -> str:
+    execute_command = "git branch --show-current"
+    LOG.info("Execute git diff command %r", execute_command)
+    command = bash.bash(execute_command)
+    if command.code:
+        logging.error('Could not find branch name: %s', command.stderr.decode())
+        sys.exit(command.code)
+
+    return cast(str, command.stdout.decode().strip())
+
+
+def _check_git_version() -> Tuple[int, ...]:
+    """
+    Show a warning if the git version used is lower than was tested with by developer
+
+    > git --version
+    git version 2.39.2 (Apple Git-143)
+
+    :return: a.b.c version format 2.39.2
+    """
+    execute_command = "git --version"
+
+    LOG.debug("Execute git diff command %r", execute_command)
+    command = bash.bash(execute_command)
+    if command.code:
+        logging.error('Could not find git version name: %s', command.stderr.decode())
+        sys.exit(command.code)
+
+    stdout = command.stdout.decode()
+    versions = tuple(int(version) for version in stdout.split()[2].split('.'))
+    if versions < MINIMUM_GIT_RECOMMEND_VERSION:
+        LOG.warning('Be aware that current git version %r is less than recomended %r',
+                    versions, MINIMUM_GIT_RECOMMEND_VERSION)
+
+    return versions
+
+
+def _pull_rebase(main_branch: str, current_branch_name: str) -> None:
+    """
+    git pull --rebase origin <main_branch>
+    """
+    execute_command = f"git pull --rebase origin {main_branch}"
+    LOG.info("Execute git pull --rebase command %r", execute_command)
+    command = bash.bash(execute_command)
+
+    if command.code:
+        logging.warning('Pull command failed: %s', command.stderr.decode())
+        return None
+
+    stdout = command.stdout.decode().strip()
+    LOG.info("git pull: %s", stdout)
+
+    LOG.info('HINTS: revert pull with: \n'
+             '>>> git reset --hard origin/%s', current_branch_name)
+
+    return None
+
+
+def _git_sync(do_pull_rebase: bool, main_branch: str) -> Optional[str]:
+    current_branch_name: Optional[str] = None
+
+    if do_pull_rebase:
+        _check_git_version()
+        current_branch_name = _current_branch_name()
+        _pull_rebase(main_branch, current_branch_name)
+
+    return current_branch_name
+
+
+def changes(do_pull_rebase: bool = True) -> typing.Changes:
     """
     Get diff changes of current branch against master branch and
     return a mapping of affected filename and line numbers
     """
     main_branch = _autodetect_main_branch()
     LOG.info("Compare current branch with %r branch", main_branch)
 
     files: typing.Changes = defaultdict(dict)
 
-    # Add new feature
-    # 1. save last main branch commit hash into custolint.d/
-    # 2. compare the remote main branch with custolint.d/latest_<main>_branch_hash.txt
-    # 3. If there is no connection to remote to consider true with a warning else
-    # If the check fails provide hints with warning how to sync the main branch
-    #
-    # git_pull_rebase_command = f"git pull --rebase origin {main_branch}"
-    # git_pull_rebase_result = bash.bash(git_pull_rebase_command)
-    # LOG.info("Sync main branch with current branch with command %r", git_pull_rebase_command)
-    #
-    # if git_pull_rebase_result.code:
-    #     logging.error('Sync command failed: %s', git_pull_rebase_result.stderr.decode())
-    #     sys.exit(git_pull_rebase_result.code)
-    #
+    _git_sync(do_pull_rebase, main_branch)
 
     the_file = ""
     execute_command = f"git diff origin/{main_branch} -U0 --diff-filter=ACMRTUXB"  # noqa: spelling
     LOG.info("Execute git diff command %r", execute_command)
     command = bash.bash(execute_command)
 
     if command.code:
```

## custolint/mypy.py

```diff
@@ -1,12 +1,15 @@
 """
 ==============================================================================
 `Mypy: Static Typing for Python <https://github.com/python/mypy>`_ integration
 ==============================================================================
 
+Logic:
+------
+
 1. Find affected files
 
 .. code-block:: bash
 
     $ git diff origin/main -U0 --diff-filter=ACMRTUXB
     INFO:custolint.git:Git diff detected 16 filed affected
 
@@ -23,15 +26,16 @@
 .. important:: if no configuration is provided custolint will fallback into strict mode
 
     .. code-block:: bash
 
         $ mypy --strict --show-error-codes file1.py ... file16.py
 
 
-3. Filter all original Mypy message with custolint rules
+Filter all original Mypy message with custolint rules
+-----------------------------------------------------
 
 .. code-block:: bash
     :caption: Final Mypy custolint command
 
     $ custolint mypy
     file16.py: message
 """
@@ -69,85 +73,121 @@
                 line_number=int(line_number),
                 message=message.strip(),
                 email=contributor['email'],
                 date=contributor['date']
             )
         return None
 
-    if len(fields) == 1 and re.search(r"Found .* errors in .* file|"
-                                      r"Success: no issues found in", fields[0]):
-        return None
+    if len(fields) == 1:
+        if re.search(r"Found .+ errors? in .+ files?", fields[0]):
+            return None
 
     if fields == ['']:
         return None
 
     if len(fields) == 2 and fields[0] == "Success":
         return None
 
     raise ValueError(str(fields))
 
 
-def _filter(path: Path, message: str, line_number: int, cache: Dict[Path, Sequence[str]]) -> bool:
+def _filter_test_function(message: str, line_content: str) -> bool:
     """
-    Return True if we want to skip the check else False if we want this check
+    SubCase of the ``_filter``function
+
+    TODO: Check in configuration what is considered test function
+    by default is ``def test_.*``
     """
-    # pylint: disable=too-many-return-statements
+    if "def test_" in line_content:
+        if f" [{errorcodes.TYPE_ARG.code}]" in message:
+            return True
 
-    # pylint: disable=duplicate-code
+        if f" [{errorcodes.NO_UNTYPED_DEF.code}]" in message:
+            return True
 
-    if generics.TEST_FILES_REGEX.search(path.name):
-        if path not in cache:
-            cache[path] = path.read_bytes().decode().splitlines()
-
-        content = cache[path]
-
-        line_content = content[line_number - 1]
-        previous_line_content = content[line_number - 2] if line_number - 2 >= 0 else None
-
-        # pylint: disable=c-extension-no-member
-        # if a function have a 'dummy' or 'mock' in word in its name
-        # then it can be skipped for check
-        if all((
-            f" [{errorcodes.NO_UNTYPED_DEF.code}]" in message,
-            re.search(r'def .*(dummy|mock).*\(', line_content),
-        )):
+        if f" [{errorcodes.ATTR_DEFINED.code}]" in message:
             return True
 
-        # mock a transient attribute
-        # e.g.
-        # mock.patch.object(generics.git, "changes", return_value={
-        # test_b.py:78 Module has no attribute "git" [attr-defined]
-        if all((
-                f" [{errorcodes.ATTR_DEFINED.code}]" in message,
-                re.search(r'(mock|mocker)\.patch\.object\(', line_content),
-        )):
+        if "Use \"-> None\" if function does not return a value" in message:
             return True
-        # if the line is split check previous line
-        if previous_line_content and all((
-                f" [{errorcodes.ATTR_DEFINED.code}]" in message,
-                re.search(r'(mock|mocker)\.patch\.object\(', previous_line_content),
-        )):
+
+        if "dict-item" in message:
             return True
-    # pylint: enable=duplicate-code
 
-        if "def test_" in line_content:
-            if f" [{errorcodes.TYPE_ARG.code}]" in message:
-                return True
+    return False
+
 
-            if f" [{errorcodes.NO_UNTYPED_DEF.code}]" in message:
-                return True
+def _filter_test_function_attr_defined(message: str,
+                                       line_content: str,
+                                       previous_line_content: Optional[str]) -> bool:
+    mocking_line = re.compile(r'(mock|mocker)\.patch\.object\(')
+
+    # mock a transient attribute which is not declared in __all__
+    # e.g.
+    # mock.patch.object(generics.git, "changes", return_value={
+    # test_b.py:78 Module has no attribute "git" [attr-defined]
+    if all((
+            f" [{errorcodes.ATTR_DEFINED.code}]" in message,
+            mocking_line.search(line_content),
+    )):
+        return True
+
+    # if the line is split check previous lineform
+    if previous_line_content and all((
+            f" [{errorcodes.ATTR_DEFINED.code}]" in message,
+            mocking_line.search(previous_line_content),
+    )):
+        return True
+
+    # It is normal practice to patch private api in tests
+    # from a.b.c.d import e
+    # ORIGINAL_E_GET_TIME = e._get_time
+    if re.search(r'Module ".+" does not explicitly export attribute "_.+"', message):
+        return True
+
+    if 'Missing type parameters for generic type "Callable"  [type-arg]' in message:
+        return True
+
+    return False
+
+
+def _filter(path: Path, message: str, line_number: int, cache: Dict[Path, Sequence[str]]) -> bool:
+    """
+    Return True if we want to skip the check else False if we want this check
+    """
+    # pylint: disable=too-many-return-statements
+
+    # pylint: disable=duplicate-code
+    if not generics.TEST_FILES_REGEX.search(path.name):
+        return False
 
-            if f" [{errorcodes.ATTR_DEFINED.code}]" in message:
-                return True
+    if path not in cache:
+        cache[path] = path.read_bytes().decode().splitlines()
 
-            if "Use \"-> None\" if function does not return a value" in message:
-                return True
+    content = cache[path]
 
-            if "dict-item" in message:
-                return True
+    line_content = content[line_number - 1]
+    previous_line_content = content[line_number - 2] if line_number - 2 >= 0 else None
+
+    # pylint: disable=c-extension-no-member
+    # if a function have a 'dummy' or 'mock' in word in its name
+    # then it can be skipped for check
+    if all((
+        f" [{errorcodes.NO_UNTYPED_DEF.code}]" in message,
+        re.search(r'def .*(dummy|mock).*\(', line_content),
+    )):
+        return True
+
+    do_filter = _filter_test_function_attr_defined(message, line_content, previous_line_content)
+    if do_filter:
+        return do_filter
+
+    do_filter = _filter_test_function(message, line_content)
+    if do_filter:
+        return do_filter
 
     return False
 
 
 def _parse_message_line(message: str) -> Sequence[str]:
     return message.split(":", 3)  # filepath, line number, level, message
```

## custolint/pylint.py

```diff
@@ -25,70 +25,102 @@
 .. code-block:: bash
     :caption: Final PyLint custolint command
 
     $ custolint pylint
     file16.py: message
 
 """
-from typing import Dict, Iterable, Iterator, Sequence, Union
+from typing import Dict, Iterable, Iterator, Sequence, Union, Optional
 
 import re
 from pathlib import Path
 
 from . import env, generics, typing
 
 
-def _filter(path: Path, message: str, line_number: int, cache: Dict[Path, Sequence[str]]) -> bool:
-    """
-    Return True if we want to skip the check else False if we want this check
-    """
-    # pylint: disable=too-many-return-statements
+def _filter_test_function(message: str, line_content: str) -> bool:  # pylint: disable=too-many-return-statements
+    # :check-description: test methods does not require to provide docstring
+    if "def test_" in line_content:
+        if '(missing-function-docstring)' in message:
+            return True
 
-    if path not in cache:
-        cache[path] = path.read_bytes().decode().splitlines()
+    # :check-description: fixtures in test does not require to provide docstring
+    # e.g. def mock_get_data(*_, **__):
+    if 'def mock_' in line_content:
+        return True
 
-    content = cache[path]
+    if ' (missing-module-docstring)' in message:
+        return True
 
-    line_content = content[line_number - 1]
-    if generics.TEST_FILES_REGEX.search(path.name):
-        if "def test_" in line_content:
-            if '(missing-function-docstring)' in message:
-                return True
+    if " (protected-access)" in message:
+        return True
 
-        if ' (missing-module-docstring)' in message:
-            return True
+    if " (too-many-public-methods)" in message:
+        return True
 
-        if " (protected-access)" in message:
-            return True
+    if 'R0801: Similar lines in ' in message:
+        return True
 
-        if " (too-many-public-methods)" in message:
-            return True
+    return False
 
-        if 'R0801: Similar lines in ' in message:
-            return True
 
+def _filter_all_function(message: str,
+                         line_content: str,
+                         previous_line_content: Optional[str]) -> bool:
+    # :check-description:
+    # if function has embedded the description in the name do not ask for additional description
+    # e.g. ``def is_valid_target(``, ``update_calculation_id`` TODO: check for verbs in future
     if all((
-        ' (missing-function-docstring)' in message,
-        re.search(r"^\s*def \w{4,}_\w{4,}(_\w{4,})+\(", line_content)
+            ' (missing-function-docstring)' in message,
+            re.search(r"^\s*def (\w{4,}|is|has|do)_\w{4,}(_\w{4,}|id)+\(", line_content)
     )):
         return True
 
+    # :check-description: if a property then do not ask for a description
+    if all(
+            ('@property' in (previous_line_content or ''),
+             ' (missing-function-docstring)' in message
+             )):
+        return True
+
     if all((
-        ' (logging-fstring-interpolation)' in message,
-        re.search(r"\w\.(critical|error|warning|info)\(", line_content)
+            ' (logging-fstring-interpolation)' in message,
+            re.search(r"\w\.(critical|error|warning|info)\(", line_content)
     )):
         return True
 
     # ignore all TODO marked with Jira reference
     if re.search(r"TODO: [A-Z]{3,}-\d+: ", message, re.IGNORECASE):
         return True
 
     return False
 
 
+def _filter(path: Path, message: str, line_number: int, cache: Dict[Path, Sequence[str]]) -> bool:
+    """
+    Return True if we want to skip the check else False if we want this check
+    """
+    # pylint: disable=too-many-return-statements
+
+    if path not in cache:
+        cache[path] = path.read_bytes().decode().splitlines()
+
+    content = cache[path]
+
+    line_content = content[line_number - 1]
+    previous_line_content = content[line_number - 2] if line_number - 2 >= 0 else None
+
+    if generics.TEST_FILES_REGEX.search(path.name):
+        do_filter = _filter_test_function(message, line_content)
+        if do_filter:
+            return True
+
+    return _filter_all_function(message, line_content, previous_line_content)
+
+
 def compare_with_main_branch(
         filters: Iterable[typing.FiltersType] = (_filter, )
 ) -> Iterator[Union[typing.Lint, typing.FiltersType]]:
     """
     Compare all pylint messages against code different to target branch.
     """
     config = Path(env.CONFIG_D, 'pylintrc')
```

## Comparing `custolint-0.1.14.dist-info/LICENSE.rst` & `custolint-0.2.1.dist-info/LICENSE.rst`

 * *Files identical despite different names*

## Comparing `custolint-0.1.14.dist-info/METADATA` & `custolint-0.2.1.dist-info/METADATA`

 * *Files 7% similar despite different names*

```diff
@@ -1,24 +1,26 @@
 Metadata-Version: 2.1
 Name: custolint
-Version: 0.1.14
+Version: 0.2.1
 Summary: Another custom linter layer
 License: MIT License
 Keywords: static code analysis,linter,python,lint,coverage,flake8
 Classifier: Environment :: Console
 Classifier: Intended Audience :: Developers
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3
 Classifier: Topic :: Software Development :: Debuggers
 Classifier: Topic :: Software Development :: Quality Assurance
 Classifier: Topic :: Software Development :: Testing
 License-File: LICENSE.rst
 Requires-Dist: bash (==0.6)
 Requires-Dist: isort (==5.10.1)
+Requires-Dist: click (==8.1.3)
+Requires-Dist: colorlog (==6.7.0)
 Provides-Extra: deploy_to_pip
 Requires-Dist: twine ; extra == 'deploy_to_pip'
 Requires-Dist: build ; extra == 'deploy_to_pip'
 Provides-Extra: dev
 Requires-Dist: pytest ; extra == 'dev'
 Requires-Dist: pylint ; extra == 'dev'
 Requires-Dist: coverage ; extra == 'dev'
@@ -47,15 +49,16 @@
 - `MyPy <src/custolint/mypy.py>`_
 - `Python Coverage <src/custolint/coverage.py>`_
 
 
 Motivation
 ----------
 
-You cannot just add a linter and activate 100% inspections when you have a large, ancient codebase with thousands of lines.
+You cannot just add a linter and activate 100% inspections when you have a large,
+ancient codebase with thousands of lines.
 
 |Boromir Meme|
 
 Instead, you only make 1% of the checks available, which is really frustrating for a decent developer.
 
 *You could enable those 100% checks just for your changes with "custolint"*.
 
@@ -122,33 +125,36 @@
 Install
 -------
 
 From pip
 
 .. code-block::
 
-    $ make install
+    $ make update_pip_and_wheel install
     pip install custolint
     Collecting custolint
       Downloading custolint-...-py3-none-any.whl (8.4 kB)
     Collecting bash...
     Installing collected packages: ...
     Successfully installed ... custolint-...
 
 From GIT
 
 .. code-block::
 
     git clone https://github.com/a-da/custolint.git
 
+    cd custolint
+
     # prod
-    pip install .
+    $ make update_pip_and_wheel install
 
     # dev
-    pip install -e .[dev]
+    $ make update_pip_and_wheel install
+    make update_pip_and_wheel install_dev
 
 
 How to run:
 -----------
 
 .. code-block::
```

