# Comparing `tmp/pedalboard-0.7.3-pp39-pypy39_pp73-win_amd64.whl.zip` & `tmp/pedalboard-0.7.4-pp39-pypy39_pp73-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,18 +1,19 @@
-Zip file size: 3000512 bytes, number of entries: 16
--rw-rw-rw-  2.0 fat  7315456 b- defN 23-Apr-10 15:12 pedalboard_native.pypy39-pp73-win_amd64.pyd
--rw-rw-rw-  2.0 fat     1917 b- defN 23-Apr-10 15:06 pedalboard/__init__.py
--rw-rw-rw-  2.0 fat    34106 b- defN 23-Apr-10 15:06 pedalboard/_pedalboard.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-10 15:06 pedalboard/py.typed
--rw-rw-rw-  2.0 fat      705 b- defN 23-Apr-10 15:06 pedalboard/version.py
--rw-rw-rw-  2.0 fat      478 b- defN 23-Apr-10 15:06 pedalboard/io/__init__.py
--rw-rw-rw-  2.0 fat    35658 b- defN 23-Apr-10 15:06 pedalboard_native/__init__.pyi
--rw-rw-rw-  2.0 fat     1878 b- defN 23-Apr-10 15:06 pedalboard_native/_internal/__init__.pyi
--rw-rw-rw-  2.0 fat    38738 b- defN 23-Apr-10 15:06 pedalboard_native/io/__init__.pyi
--rw-rw-rw-  2.0 fat      937 b- defN 23-Apr-10 15:06 pedalboard_native/utils/__init__.pyi
--rw-rw-rw-  2.0 fat    35823 b- defN 23-Apr-10 15:12 pedalboard-0.7.3.dist-info/LICENSE
--rw-rw-rw-  2.0 fat    14623 b- defN 23-Apr-10 15:12 pedalboard-0.7.3.dist-info/METADATA
--rw-rw-rw-  2.0 fat      589 b- defN 23-Apr-10 15:12 pedalboard-0.7.3.dist-info/NOTICE
--rw-rw-rw-  2.0 fat      107 b- defN 23-Apr-10 15:12 pedalboard-0.7.3.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       29 b- defN 23-Apr-10 15:12 pedalboard-0.7.3.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1357 b- defN 23-Apr-10 15:12 pedalboard-0.7.3.dist-info/RECORD
-16 files, 7482401 bytes uncompressed, 2998272 bytes compressed:  59.9%
+Zip file size: 3021205 bytes, number of entries: 17
+-rw-rw-rw-  2.0 fat  7351808 b- defN 23-Jun-15 17:39 pedalboard_native.pypy39-pp73-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     1917 b- defN 23-Jun-15 17:35 pedalboard/__init__.py
+-rw-rw-rw-  2.0 fat    32061 b- defN 23-Jun-15 17:35 pedalboard/_pedalboard.py
+-rw-rw-rw-  2.0 fat     3527 b- defN 23-Jun-15 17:35 pedalboard/midi_utils.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-15 17:35 pedalboard/py.typed
+-rw-rw-rw-  2.0 fat      705 b- defN 23-Jun-15 17:35 pedalboard/version.py
+-rw-rw-rw-  2.0 fat      478 b- defN 23-Jun-15 17:35 pedalboard/io/__init__.py
+-rw-rw-rw-  2.0 fat    64646 b- defN 23-Jun-15 17:35 pedalboard_native/__init__.pyi
+-rw-rw-rw-  2.0 fat     2588 b- defN 23-Jun-15 17:35 pedalboard_native/_internal/__init__.pyi
+-rw-rw-rw-  2.0 fat    38749 b- defN 23-Jun-15 17:35 pedalboard_native/io/__init__.pyi
+-rw-rw-rw-  2.0 fat     1647 b- defN 23-Jun-15 17:35 pedalboard_native/utils/__init__.pyi
+-rw-rw-rw-  2.0 fat    35823 b- defN 23-Jun-15 17:39 pedalboard-0.7.4.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat    15648 b- defN 23-Jun-15 17:39 pedalboard-0.7.4.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      589 b- defN 23-Jun-15 17:39 pedalboard-0.7.4.dist-info/NOTICE
+-rw-rw-rw-  2.0 fat      107 b- defN 23-Jun-15 17:39 pedalboard-0.7.4.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       29 b- defN 23-Jun-15 17:39 pedalboard-0.7.4.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1439 b- defN 23-Jun-15 17:39 pedalboard-0.7.4.dist-info/RECORD
+17 files, 7551761 bytes uncompressed, 3018841 bytes compressed:  60.0%
```

## zipnote {}

```diff
@@ -3,14 +3,17 @@
 
 Filename: pedalboard/__init__.py
 Comment: 
 
 Filename: pedalboard/_pedalboard.py
 Comment: 
 
+Filename: pedalboard/midi_utils.py
+Comment: 
+
 Filename: pedalboard/py.typed
 Comment: 
 
 Filename: pedalboard/version.py
 Comment: 
 
 Filename: pedalboard/io/__init__.py
@@ -24,26 +27,26 @@
 
 Filename: pedalboard_native/io/__init__.pyi
 Comment: 
 
 Filename: pedalboard_native/utils/__init__.pyi
 Comment: 
 
-Filename: pedalboard-0.7.3.dist-info/LICENSE
+Filename: pedalboard-0.7.4.dist-info/LICENSE
 Comment: 
 
-Filename: pedalboard-0.7.3.dist-info/METADATA
+Filename: pedalboard-0.7.4.dist-info/METADATA
 Comment: 
 
-Filename: pedalboard-0.7.3.dist-info/NOTICE
+Filename: pedalboard-0.7.4.dist-info/NOTICE
 Comment: 
 
-Filename: pedalboard-0.7.3.dist-info/WHEEL
+Filename: pedalboard-0.7.4.dist-info/WHEEL
 Comment: 
 
-Filename: pedalboard-0.7.3.dist-info/top_level.txt
+Filename: pedalboard-0.7.4.dist-info/top_level.txt
 Comment: 
 
-Filename: pedalboard-0.7.3.dist-info/RECORD
+Filename: pedalboard-0.7.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pedalboard/_pedalboard.py

```diff
@@ -33,14 +33,19 @@
     :class:`Pedalboard` objects act like regular Python ``List`` objects,
     but come with an additional :py:meth:`process` method (also aliased to :py:meth:`__call__`),
     allowing audio to be passed through the entire :class:`Pedalboard` object for processing::
 
         my_pedalboard = Pedalboard()
         my_pedalboard.append(Reverb())
         output_audio = my_pedalboard(input_audio)
+
+    .. warning::
+        :class:`Pedalboard` objects may only contain effects plugins (i.e.: those for which
+        :attr:`is_effect` is ``True``), and cannot contain instrument plugins (i.e.: those
+        for which :attr:`is_instrument` is ``True``).
     """
 
     def __init__(self, plugins: Optional[List[Plugin]] = None):
         super().__init__(plugins or [])
 
     def __repr__(self) -> str:
         return "<{} with {} plugin{}: {}>".format(
@@ -55,15 +60,15 @@
     ["x", "%", "*", ",", ".", "hz", "ms", "sec", "seconds", "dB", "dBTP"]
 )
 
 
 def strip_common_float_suffixes(
     s: Union[float, str, bool], strip_si_prefixes: bool = True
 ) -> Union[float, str, bool]:
-    if not isinstance(s, str) or (hasattr(s, "type") and s.type != str):
+    if not isinstance(s, str) or (hasattr(s, "type") and s.type != str):  # type: ignore
         return s
 
     s = s.strip()
 
     # Handle certain plugins that report "Hz" and "kHz" suffixes:
     if strip_si_prefixes:
         if s.lower().endswith("khz") and len(s) > 3:
@@ -569,16 +574,24 @@
     # Remove any leading or trailing underscores:
     name = "".join(name_chars).strip("_")
     return name
 
 
 class _PythonExternalPluginMixin:
     def __set_initial_parameter_values__(
-        self, parameter_values: Dict[str, Union[str, int, float, bool]] = {}
+        self, parameter_values: Optional[Dict[str, Union[str, int, float, bool]]]
     ):
+        if parameter_values is None:
+            parameter_values = {}
+        if not isinstance(parameter_values, dict):
+            raise TypeError(
+                "Expected a dictionary to be passed to parameter_values, but received a"
+                f" {type(parameter_values).__name__}. (If passing a plugin name, pass"
+                ' "plugin_name=..." as a keyword argument instead.)'
+            )
         parameters = self.parameters
         for key, value in parameter_values.items():
             if key not in parameters:
                 raise AttributeError(
                     'Parameter named "{}" not found. Valid options: {}'.format(
                         key, ", ".join(self._parameter_weakrefs.keys())
                     )
@@ -666,88 +679,29 @@
             parameter = self._get_parameter_by_python_name(name)
             if parameter:
                 parameter.raw_value = parameter.get_raw_value_for(value)
                 return
         super().__setattr__(name, value)
 
 
-_AVAILABLE_PLUGIN_CLASSES: List[Type[ExternalPlugin]] = []
+ExternalPlugin.__bases__ = ExternalPlugin.__bases__ + (_PythonExternalPluginMixin,)
 
-try:
-    from pedalboard_native import _VST3Plugin
 
-    class VST3Plugin(_VST3Plugin, _PythonExternalPluginMixin):
-        """
-        A wrapper around third-party, non-Pedalboard audio effects
-        plugins in
-        `Steinberg GmbH's VST3® <https://en.wikipedia.org/wiki/Virtual_Studio_Technology>`_
-        format.
-
-        VST3® plugins are supported on macOS, Windows, and Linux.
-        However, VST3® plugin files are not cross-compatible with
-        different operating systems; a platform-specific build of each plugin
-        is required to load that plugin on a given platform. (For example:
-        a Windows VST3 plugin bundle will not load on Linux or macOS.)
-        """
-
-        def __init__(
-            self,
-            path_to_plugin_file: str,
-            parameter_values: Dict[str, Union[str, int, float, bool]] = {},
-            plugin_name: Optional[str] = None,
-        ):
-            if not isinstance(parameter_values, dict):
-                raise TypeError(
-                    "Expected a dictionary to be passed to parameter_values, but received a"
-                    f" {type(parameter_values).__name__}. (If passing a plugin name, pass"
-                    ' "plugin_name=..." as a keyword argument instead.)'
-                )
+_AVAILABLE_PLUGIN_CLASSES: List[Type[ExternalPlugin]] = []
 
-            _VST3Plugin.__init__(self, path_to_plugin_file, plugin_name)
-            self.__set_initial_parameter_values__(parameter_values)
+try:
+    from pedalboard_native import VST3Plugin  # type: ignore
 
     _AVAILABLE_PLUGIN_CLASSES.append(VST3Plugin)
 except ImportError:
     # We may be on a system that doesn't have native VST3Plugin support.
     pass
 
 try:
-    from pedalboard_native import _AudioUnitPlugin
-
-    class AudioUnitPlugin(_AudioUnitPlugin, _PythonExternalPluginMixin):
-        """
-        A wrapper around third-party, non-Pedalboard audio effects
-        plugins in
-        `Apple's Audio Unit <https://en.wikipedia.org/wiki/Audio_Units>`_
-        format.
-
-        Audio Unit plugins are only supported on macOS. This class will be
-        unavailable on non-macOS platforms. Plugin files must be installed
-        in the appropriate system-wide path for them to be
-        loadable (usually ``/Library/Audio/Plug-Ins/Components/`` or
-        ``~/Library/Audio/Plug-Ins/Components/``).
-
-        For a plugin wrapper that works on Windows and Linux as well,
-        see :class:`pedalboard.VST3Plugin`.
-        """
-
-        def __init__(
-            self,
-            path_to_plugin_file: str,
-            parameter_values: Dict[str, Union[str, int, float, bool]] = {},
-            plugin_name: Optional[str] = None,
-        ):
-            if not isinstance(parameter_values, dict):
-                raise TypeError(
-                    "Expected a dictionary to be passed to parameter_values, but received a"
-                    f" {type(parameter_values).__name__}. (If passing a plugin name, pass"
-                    ' "plugin_name=..." as a keyword argument instead.)'
-                )
-            _AudioUnitPlugin.__init__(self, path_to_plugin_file, plugin_name)
-            self.__set_initial_parameter_values__(parameter_values)
+    from pedalboard_native import AudioUnitPlugin  # type: ignore
 
     _AVAILABLE_PLUGIN_CLASSES.append(AudioUnitPlugin)
 except ImportError:
     # We may be on a system that doesn't have native AudioUnitPlugin support.
     # (i.e.: any platform that's not macOS.)
     pass
```

## pedalboard/version.py

```diff
@@ -13,10 +13,10 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
 
 MAJOR = 0
 MINOR = 7
-PATCH = 3
+PATCH = 4
 
 __version__ = "%d.%d.%d" % (MAJOR, MINOR, PATCH)
```

## pedalboard_native/__init__.pyi

```diff
@@ -1,20 +1,42 @@
-"""This module provides classes and functions for adding effects to audio. Most classes in this module are subclasses of ``Plugin``, each of which allows applying effects to an audio buffer or stream.
+"""This module provides classes and functions for generating and adding effects to audio. Most classes in this module are subclasses of ``Plugin``, each of which allows applying effects to an audio buffer or stream.
 
 For audio I/O classes (i.e.: reading and writing audio files), see ``pedalboard.io``."""
 from __future__ import annotations
 import pedalboard_native
+
 import typing
+
+original_overload = typing.overload
+__OVERLOADED_DOCSTRINGS = {}
+
+def patch_overload(func):
+    original_overload(func)
+    if func.__doc__:
+        __OVERLOADED_DOCSTRINGS[func.__qualname__] = func.__doc__
+    else:
+        func.__doc__ = __OVERLOADED_DOCSTRINGS.get(func.__qualname__)
+    if func.__doc__:
+        # Work around the fact that pybind11-stubgen generates
+        # duplicate docstrings sometimes, once for each overload:
+        docstring = func.__doc__
+        if docstring[len(docstring) // 2 :].strip() == docstring[: -len(docstring) // 2].strip():
+            func.__doc__ = docstring[len(docstring) // 2 :].strip()
+    return func
+
+typing.overload = patch_overload
+
 from typing_extensions import Literal
 from enum import Enum
 import numpy
 
 _Shape = typing.Tuple[int, ...]
 
 __all__ = [
+    "AudioUnitPlugin",
     "Bitcrush",
     "Chorus",
     "Clipping",
     "Compressor",
     "Convolution",
     "Delay",
     "Distortion",
@@ -34,14 +56,15 @@
     "PeakFilter",
     "Phaser",
     "PitchShift",
     "Plugin",
     "PluginContainer",
     "Resample",
     "Reverb",
+    "VST3Plugin",
     "io",
     "process",
     "utils",
 ]
 
 class Plugin:
     """
@@ -95,14 +118,55 @@
 
 
         """
     def reset(self) -> None:
         """
         Clear any internal state stored by this plugin (e.g.: reverb tails, delay lines, LFO state, etc). The values of plugin parameters will remain unchanged.
         """
+    @property
+    def is_effect(self) -> bool:
+        """
+        True iff this plugin is an audio effect and accepts audio as input.
+
+        *Introduced in v0.7.4.*
+
+
+        """
+    @property
+    def is_instrument(self) -> bool:
+        """
+        True iff this plugin is not an audio effect and accepts only MIDI input, not audio.
+
+        *Introduced in v0.7.4.*
+
+
+        """
+    pass
+
+class Bitcrush(Plugin):
+    """
+    A plugin that reduces the signal to a given bit depth, giving the audio a lo-fi, digitized sound. Floating-point bit depths are supported.
+
+    Bitcrushing changes the amount of "vertical" resolution used for an audio signal (i.e.: how many unique values could be used to represent each sample). For an effect that changes the "horizontal" resolution (i.e.: how many samples are available per second), see :class:`pedalboard.Resample`.
+    """
+
+    def __init__(self, bit_depth: float = 8) -> None: ...
+    def __repr__(self) -> str: ...
+    @property
+    def bit_depth(self) -> float:
+        """
+        The bit depth to quantize the signal to. Must be between 0 and 32 bits. May be an integer, decimal, or floating-point value. Each audio sample will be quantized onto ``2 ** bit_depth`` values.
+
+
+        """
+    @bit_depth.setter
+    def bit_depth(self, arg1: float) -> None:
+        """
+        The bit depth to quantize the signal to. Must be between 0 and 32 bits. May be an integer, decimal, or floating-point value. Each audio sample will be quantized onto ``2 ** bit_depth`` values.
+        """
     pass
 
 class Chorus(Plugin):
     """
     A basic chorus effect.
 
     This audio effect can be controlled via the speed and depth of the LFO controlling the frequency response, a mix control, a feedback control, and the centre delay of the modulation.
@@ -276,16 +340,227 @@
     def drive_db(self, arg1: float) -> None:
         pass
     pass
 
 class ExternalPlugin(Plugin):
     """
     A wrapper around a third-party effect plugin.
+
+    Don't use this directly; use one of :class:`pedalboard.VST3Plugin` or :class:`pedalboard.AudioUnitPlugin` instead.
     """
 
+    @typing.overload
+    def __call__(
+        self,
+        midi_messages: object,
+        duration: float,
+        sample_rate: float,
+        num_channels: int = 2,
+        buffer_size: int = 8192,
+        reset: bool = True,
+    ) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]:
+        """
+        Run an audio or MIDI buffer through this plugin, returning audio. Alias for :py:meth:`process`.
+
+        Run an audio or MIDI buffer through this plugin, returning audio. Alias for :py:meth:`process`.
+        """
+    @typing.overload
+    def __call__(
+        self,
+        input_array: numpy.ndarray,
+        sample_rate: float,
+        buffer_size: int = 8192,
+        reset: bool = True,
+    ) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]: ...
+    @typing.overload
+    def process(
+        self,
+        midi_messages: object,
+        duration: float,
+        sample_rate: float,
+        num_channels: int = 2,
+        buffer_size: int = 8192,
+        reset: bool = True,
+    ) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]:
+        """
+        Pass a buffer of audio (as a 32- or 64-bit NumPy array) *or* a list of
+        MIDI messages to this plugin, returning audio.
+
+        (If calling this multiple times with multiple effect plugins, consider
+        creating a :class:`pedalboard.Pedalboard` object instead.)
+
+        When provided audio as input, the returned array may contain up to (but not
+        more than) the same number of samples as were provided. If fewer samples
+        were returned than expected, the plugin has likely buffered audio inside
+        itself. To receive the remaining audio, pass another audio buffer into
+        ``process`` with ``reset`` set to ``True``.
+
+        If the provided buffer uses a 64-bit datatype, it will be converted to 32-bit
+        for processing.
+
+        If provided MIDI messages as input, the provided ``midi_messages`` must be
+        a Python ``List`` containing one of the following types:
+
+         - Objects with a ``bytes()`` method and ``time`` property (such as :doc:`mido:messages`
+           from :doc:`mido:index`, not included with Pedalboard)
+         - Tuples that look like: ``(midi_bytes: bytes, timestamp_in_seconds: float)``
+         - Tuples that look like: ``(midi_bytes: List[int], timestamp_in_seconds: float)``
+
+        The returned array will contain ``duration`` seconds worth of audio at the
+        provided ``sample_rate``.
+
+        Each MIDI message will be sent to the plugin at its
+        timestamp, where a timestamp of ``0`` indicates the start of the buffer, and
+        a timestamp equal to ``duration`` indicates the end of the buffer. (Any MIDI
+        messages whose timestamps are greater than ``duration`` will be ignored.)
+
+        The provided ``buffer_size`` argument will be used to control the size of
+        each chunk of audio returned by the plugin at once. Higher buffer sizes may
+        speed up processing, but may cause increased memory usage.
+
+        The ``reset`` flag determines if this plugin should be reset before
+        processing begins, clearing any state from previous calls to ``process``.
+        If calling ``process`` multiple times while processing the same audio or
+        MIDI stream, set ``reset`` to ``False``.
+
+        .. note::
+            The :py:meth:`process` method can also be used via :py:meth:`__call__`;
+            i.e.: just calling this object like a function (``my_plugin(...)``) will
+            automatically invoke :py:meth:`process` with the same arguments.
+
+
+        Examples
+        --------
+
+        Running audio through an external effect plugin::
+
+           from pedalboard import load_plugin
+           from pedalboard.io import AudioFile
+
+           plugin = load_plugin("../path-to-my-plugin-file")
+           assert plugin.is_effect
+           with AudioFile("input-audio.wav") as f:
+               output_audio = plugin(f.read(), f.samplerate)
+
+
+        Rendering MIDI via an external instrument plugin::
+
+           from pedalboard import load_plugin
+           from pedalboard.io import AudioFile
+           from mido import Message # not part of Pedalboard, but convenient!
+
+           plugin = load_plugin("../path-to-my-plugin-file")
+           assert plugin.is_instrument
+
+           sample_rate = 44100
+           num_channels = 2
+           with AudioFile("output-audio.wav", "w", sample_rate, num_channels) as f:
+               f.write(plugin(
+                   [Message("note_on", note=60), Message("note_off", note=60, time=4)],
+                   sample_rate=sample_rate,
+                   duration=5,
+                   num_channels=num_channels
+               ))
+
+
+        *Support for instrument plugins introduced in v0.7.4.*
+
+
+
+        Pass a buffer of audio (as a 32- or 64-bit NumPy array) *or* a list of
+        MIDI messages to this plugin, returning audio.
+
+        (If calling this multiple times with multiple effect plugins, consider
+        creating a :class:`pedalboard.Pedalboard` object instead.)
+
+        When provided audio as input, the returned array may contain up to (but not
+        more than) the same number of samples as were provided. If fewer samples
+        were returned than expected, the plugin has likely buffered audio inside
+        itself. To receive the remaining audio, pass another audio buffer into
+        ``process`` with ``reset`` set to ``True``.
+
+        If the provided buffer uses a 64-bit datatype, it will be converted to 32-bit
+        for processing.
+
+        If provided MIDI messages as input, the provided ``midi_messages`` must be
+        a Python ``List`` containing one of the following types:
+
+         - Objects with a ``bytes()`` method and ``time`` property (such as :doc:`mido:messages`
+           from :doc:`mido:index`, not included with Pedalboard)
+         - Tuples that look like: ``(midi_bytes: bytes, timestamp_in_seconds: float)``
+         - Tuples that look like: ``(midi_bytes: List[int], timestamp_in_seconds: float)``
+
+        The returned array will contain ``duration`` seconds worth of audio at the
+        provided ``sample_rate``.
+
+        Each MIDI message will be sent to the plugin at its
+        timestamp, where a timestamp of ``0`` indicates the start of the buffer, and
+        a timestamp equal to ``duration`` indicates the end of the buffer. (Any MIDI
+        messages whose timestamps are greater than ``duration`` will be ignored.)
+
+        The provided ``buffer_size`` argument will be used to control the size of
+        each chunk of audio returned by the plugin at once. Higher buffer sizes may
+        speed up processing, but may cause increased memory usage.
+
+        The ``reset`` flag determines if this plugin should be reset before
+        processing begins, clearing any state from previous calls to ``process``.
+        If calling ``process`` multiple times while processing the same audio or
+        MIDI stream, set ``reset`` to ``False``.
+
+        .. note::
+            The :py:meth:`process` method can also be used via :py:meth:`__call__`;
+            i.e.: just calling this object like a function (``my_plugin(...)``) will
+            automatically invoke :py:meth:`process` with the same arguments.
+
+
+        Examples
+        --------
+
+        Running audio through an external effect plugin::
+
+           from pedalboard import load_plugin
+           from pedalboard.io import AudioFile
+
+           plugin = load_plugin("../path-to-my-plugin-file")
+           assert plugin.is_effect
+           with AudioFile("input-audio.wav") as f:
+               output_audio = plugin(f.read(), f.samplerate)
+
+
+        Rendering MIDI via an external instrument plugin::
+
+           from pedalboard import load_plugin
+           from pedalboard.io import AudioFile
+           from mido import Message # not part of Pedalboard, but convenient!
+
+           plugin = load_plugin("../path-to-my-plugin-file")
+           assert plugin.is_instrument
+
+           sample_rate = 44100
+           num_channels = 2
+           with AudioFile("output-audio.wav", "w", sample_rate, num_channels) as f:
+               f.write(plugin(
+                   [Message("note_on", note=60), Message("note_off", note=60, time=4)],
+                   sample_rate=sample_rate,
+                   duration=5,
+                   num_channels=num_channels
+               ))
+
+
+        *Support for instrument plugins introduced in v0.7.4.*
+
+        """
+    @typing.overload
+    def process(
+        self,
+        input_array: numpy.ndarray,
+        sample_rate: float,
+        buffer_size: int = 8192,
+        reset: bool = True,
+    ) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]: ...
     pass
 
 class Gain(Plugin):
     """
     A gain plugin that increases or decreases the volume of a signal by amplifying or attenuating it by the provided value (in decibels). No distortion or other effects are applied.
 
     Think of this as a volume control.
@@ -649,34 +924,269 @@
     def semitones(self) -> float:
         """ """
     @semitones.setter
     def semitones(self, arg1: float) -> None:
         pass
     pass
 
-class Bitcrush(Plugin):
+class AudioUnitPlugin(ExternalPlugin):
     """
-    A plugin that reduces the signal to a given bit depth, giving the audio a lo-fi, digitized sound. Floating-point bit depths are supported.
+    A wrapper around third-party, audio effect or instrument
+    plugins in `Apple's Audio Unit <https://en.wikipedia.org/wiki/Audio_Units>`_
+    format.
 
-    Bitcrushing changes the amount of "vertical" resolution used for an audio signal (i.e.: how many unique values could be used to represent each sample). For an effect that changes the "horizontal" resolution (i.e.: how many samples are available per second), see :class:`pedalboard.Resample`.
+    Audio Unit plugins are only supported on macOS. This class will be
+    unavailable on non-macOS platforms. Plugin files must be installed
+    in the appropriate system-wide path for them to be
+    loadable (usually ``/Library/Audio/Plug-Ins/Components/`` or
+    ``~/Library/Audio/Plug-Ins/Components/``).
+
+    For a plugin wrapper that works on Windows and Linux as well,
+    see :class:`pedalboard.VST3Plugin`.)
+
+    *Support for instrument plugins introduced in v0.7.4.*
     """
 
-    def __init__(self, bit_depth: float = 8) -> None: ...
+    @typing.overload
+    def __call__(
+        self,
+        midi_messages: object,
+        duration: float,
+        sample_rate: float,
+        num_channels: int = 2,
+        buffer_size: int = 8192,
+        reset: bool = True,
+    ) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]:
+        """
+        Run an audio or MIDI buffer through this plugin, returning audio. Alias for :py:meth:`process`.
+
+        Run an audio or MIDI buffer through this plugin, returning audio. Alias for :py:meth:`process`.
+        """
+    @typing.overload
+    def __call__(
+        self,
+        input_array: numpy.ndarray,
+        sample_rate: float,
+        buffer_size: int = 8192,
+        reset: bool = True,
+    ) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]: ...
+    def __init__(
+        self,
+        path_to_plugin_file: str,
+        parameter_values: object = None,
+        plugin_name: typing.Optional[str] = None,
+    ) -> None: ...
     def __repr__(self) -> str: ...
-    @property
-    def bit_depth(self) -> float:
+    def _get_parameter(self, arg0: str) -> _AudioProcessorParameter: ...
+    @staticmethod
+    def get_plugin_names_for_file(filename: str) -> typing.List[str]:
         """
-        The bit depth to quantize the signal to. Must be between 0 and 32 bits. May be an integer, decimal, or floating-point value. Each audio sample will be quantized onto ``2 ** bit_depth`` values.
+        Return a list of plugin names contained within a given Audio Unit bundle (i.e.: a ``.component`` file). If the provided file cannot be scanned, an ``ImportError`` will be raised.
+
+        Note that most Audio Units have a single plugin inside, but this method can be useful to determine if multiple plugins are present in one bundle, and if so, what their names are.
+        """
+    @typing.overload
+    def process(
+        self,
+        midi_messages: object,
+        duration: float,
+        sample_rate: float,
+        num_channels: int = 2,
+        buffer_size: int = 8192,
+        reset: bool = True,
+    ) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]:
+        """
+        Pass a buffer of audio (as a 32- or 64-bit NumPy array) *or* a list of
+        MIDI messages to this plugin, returning audio.
+
+        (If calling this multiple times with multiple effect plugins, consider
+        creating a :class:`pedalboard.Pedalboard` object instead.)
+
+        When provided audio as input, the returned array may contain up to (but not
+        more than) the same number of samples as were provided. If fewer samples
+        were returned than expected, the plugin has likely buffered audio inside
+        itself. To receive the remaining audio, pass another audio buffer into
+        ``process`` with ``reset`` set to ``True``.
+
+        If the provided buffer uses a 64-bit datatype, it will be converted to 32-bit
+        for processing.
+
+        If provided MIDI messages as input, the provided ``midi_messages`` must be
+        a Python ``List`` containing one of the following types:
+
+         - Objects with a ``bytes()`` method and ``time`` property (such as :doc:`mido:messages`
+           from :doc:`mido:index`, not included with Pedalboard)
+         - Tuples that look like: ``(midi_bytes: bytes, timestamp_in_seconds: float)``
+         - Tuples that look like: ``(midi_bytes: List[int], timestamp_in_seconds: float)``
+
+        The returned array will contain ``duration`` seconds worth of audio at the
+        provided ``sample_rate``.
+
+        Each MIDI message will be sent to the plugin at its
+        timestamp, where a timestamp of ``0`` indicates the start of the buffer, and
+        a timestamp equal to ``duration`` indicates the end of the buffer. (Any MIDI
+        messages whose timestamps are greater than ``duration`` will be ignored.)
+
+        The provided ``buffer_size`` argument will be used to control the size of
+        each chunk of audio returned by the plugin at once. Higher buffer sizes may
+        speed up processing, but may cause increased memory usage.
+
+        The ``reset`` flag determines if this plugin should be reset before
+        processing begins, clearing any state from previous calls to ``process``.
+        If calling ``process`` multiple times while processing the same audio or
+        MIDI stream, set ``reset`` to ``False``.
+
+        .. note::
+            The :py:meth:`process` method can also be used via :py:meth:`__call__`;
+            i.e.: just calling this object like a function (``my_plugin(...)``) will
+            automatically invoke :py:meth:`process` with the same arguments.
+
+
+        Examples
+        --------
+
+        Running audio through an external effect plugin::
+
+           from pedalboard import load_plugin
+           from pedalboard.io import AudioFile
+
+           plugin = load_plugin("../path-to-my-plugin-file")
+           assert plugin.is_effect
+           with AudioFile("input-audio.wav") as f:
+               output_audio = plugin(f.read(), f.samplerate)
+
+
+        Rendering MIDI via an external instrument plugin::
+
+           from pedalboard import load_plugin
+           from pedalboard.io import AudioFile
+           from mido import Message # not part of Pedalboard, but convenient!
+
+           plugin = load_plugin("../path-to-my-plugin-file")
+           assert plugin.is_instrument
+
+           sample_rate = 44100
+           num_channels = 2
+           with AudioFile("output-audio.wav", "w", sample_rate, num_channels) as f:
+               f.write(plugin(
+                   [Message("note_on", note=60), Message("note_off", note=60, time=4)],
+                   sample_rate=sample_rate,
+                   duration=5,
+                   num_channels=num_channels
+               ))
+
+
+        *Support for instrument plugins introduced in v0.7.4.*
+
+
+
+        Pass a buffer of audio (as a 32- or 64-bit NumPy array) *or* a list of
+        MIDI messages to this plugin, returning audio.
+
+        (If calling this multiple times with multiple effect plugins, consider
+        creating a :class:`pedalboard.Pedalboard` object instead.)
+
+        When provided audio as input, the returned array may contain up to (but not
+        more than) the same number of samples as were provided. If fewer samples
+        were returned than expected, the plugin has likely buffered audio inside
+        itself. To receive the remaining audio, pass another audio buffer into
+        ``process`` with ``reset`` set to ``True``.
+
+        If the provided buffer uses a 64-bit datatype, it will be converted to 32-bit
+        for processing.
+
+        If provided MIDI messages as input, the provided ``midi_messages`` must be
+        a Python ``List`` containing one of the following types:
+
+         - Objects with a ``bytes()`` method and ``time`` property (such as :doc:`mido:messages`
+           from :doc:`mido:index`, not included with Pedalboard)
+         - Tuples that look like: ``(midi_bytes: bytes, timestamp_in_seconds: float)``
+         - Tuples that look like: ``(midi_bytes: List[int], timestamp_in_seconds: float)``
+
+        The returned array will contain ``duration`` seconds worth of audio at the
+        provided ``sample_rate``.
+
+        Each MIDI message will be sent to the plugin at its
+        timestamp, where a timestamp of ``0`` indicates the start of the buffer, and
+        a timestamp equal to ``duration`` indicates the end of the buffer. (Any MIDI
+        messages whose timestamps are greater than ``duration`` will be ignored.)
+
+        The provided ``buffer_size`` argument will be used to control the size of
+        each chunk of audio returned by the plugin at once. Higher buffer sizes may
+        speed up processing, but may cause increased memory usage.
+
+        The ``reset`` flag determines if this plugin should be reset before
+        processing begins, clearing any state from previous calls to ``process``.
+        If calling ``process`` multiple times while processing the same audio or
+        MIDI stream, set ``reset`` to ``False``.
+
+        .. note::
+            The :py:meth:`process` method can also be used via :py:meth:`__call__`;
+            i.e.: just calling this object like a function (``my_plugin(...)``) will
+            automatically invoke :py:meth:`process` with the same arguments.
 
 
+        Examples
+        --------
+
+        Running audio through an external effect plugin::
+
+           from pedalboard import load_plugin
+           from pedalboard.io import AudioFile
+
+           plugin = load_plugin("../path-to-my-plugin-file")
+           assert plugin.is_effect
+           with AudioFile("input-audio.wav") as f:
+               output_audio = plugin(f.read(), f.samplerate)
+
+
+        Rendering MIDI via an external instrument plugin::
+
+           from pedalboard import load_plugin
+           from pedalboard.io import AudioFile
+           from mido import Message # not part of Pedalboard, but convenient!
+
+           plugin = load_plugin("../path-to-my-plugin-file")
+           assert plugin.is_instrument
+
+           sample_rate = 44100
+           num_channels = 2
+           with AudioFile("output-audio.wav", "w", sample_rate, num_channels) as f:
+               f.write(plugin(
+                   [Message("note_on", note=60), Message("note_off", note=60, time=4)],
+                   sample_rate=sample_rate,
+                   duration=5,
+                   num_channels=num_channels
+               ))
+
+
+        *Support for instrument plugins introduced in v0.7.4.*
+
         """
-    @bit_depth.setter
-    def bit_depth(self, arg1: float) -> None:
+    @typing.overload
+    def process(
+        self,
+        input_array: numpy.ndarray,
+        sample_rate: float,
+        buffer_size: int = 8192,
+        reset: bool = True,
+    ) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]: ...
+    def show_editor(self) -> None:
         """
-        The bit depth to quantize the signal to. Must be between 0 and 32 bits. May be an integer, decimal, or floating-point value. Each audio sample will be quantized onto ``2 ** bit_depth`` values.
+        Show the UI of this plugin as a native window. This method will block until the window is closed or a KeyboardInterrupt is received.
+        """
+    @property
+    def _parameters(self) -> typing.List[_AudioProcessorParameter]:
+        """ """
+    @property
+    def name(self) -> str:
+        """
+        The name of this plugin, as reported by the plugin itself.
+
+
         """
     pass
 
 class PluginContainer(Plugin):
     """
     A generic audio processing plugin that contains zero or more other plugins. Not intended for direct use.
     """
@@ -828,14 +1338,270 @@
     def width(self) -> float:
         """ """
     @width.setter
     def width(self, arg1: float) -> None:
         pass
     pass
 
+class VST3Plugin(ExternalPlugin):
+    """
+    A wrapper around third-party, audio effect or instrument plugins in
+    `Steinberg GmbH's VST3® <https://en.wikipedia.org/wiki/Virtual_Studio_Technology>`_
+    format.
+
+    VST3® plugins are supported on macOS, Windows, and Linux. However, VST3® plugin
+    files are not cross-compatible with different operating systems; a platform-specific
+    build of each plugin is required to load that plugin on a given platform. (For
+    example: a Windows VST3 plugin bundle will not load on Linux or macOS.)
+
+    *Support for instrument plugins introduced in v0.7.4.*
+    """
+
+    @typing.overload
+    def __call__(
+        self,
+        input_array: numpy.ndarray,
+        sample_rate: float,
+        buffer_size: int = 8192,
+        reset: bool = True,
+    ) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]:
+        """
+        Run an audio or MIDI buffer through this plugin, returning audio. Alias for :py:meth:`process`.
+
+        Run an audio or MIDI buffer through this plugin, returning audio. Alias for :py:meth:`process`.
+        """
+    @typing.overload
+    def __call__(
+        self,
+        midi_messages: object,
+        duration: float,
+        sample_rate: float,
+        num_channels: int = 2,
+        buffer_size: int = 8192,
+        reset: bool = True,
+    ) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]: ...
+    def __init__(
+        self,
+        path_to_plugin_file: str,
+        parameter_values: object = None,
+        plugin_name: typing.Optional[str] = None,
+    ) -> None: ...
+    def __repr__(self) -> str: ...
+    def _get_parameter(self, arg0: str) -> _AudioProcessorParameter: ...
+    @staticmethod
+    def get_plugin_names_for_file(arg0: str) -> typing.List[str]:
+        """
+        Return a list of plugin names contained within a given VST3 plugin (i.e.: a ".vst3"). If the provided file cannot be scanned, an ImportError will be raised.
+        """
+    def load_preset(self, preset_file_path: str) -> None:
+        """
+        Load a VST3 preset file in .vstpreset format.
+        """
+    @typing.overload
+    def process(
+        self,
+        input_array: numpy.ndarray,
+        sample_rate: float,
+        buffer_size: int = 8192,
+        reset: bool = True,
+    ) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]:
+        """
+        Pass a buffer of audio (as a 32- or 64-bit NumPy array) *or* a list of
+        MIDI messages to this plugin, returning audio.
+
+        (If calling this multiple times with multiple effect plugins, consider
+        creating a :class:`pedalboard.Pedalboard` object instead.)
+
+        When provided audio as input, the returned array may contain up to (but not
+        more than) the same number of samples as were provided. If fewer samples
+        were returned than expected, the plugin has likely buffered audio inside
+        itself. To receive the remaining audio, pass another audio buffer into
+        ``process`` with ``reset`` set to ``True``.
+
+        If the provided buffer uses a 64-bit datatype, it will be converted to 32-bit
+        for processing.
+
+        If provided MIDI messages as input, the provided ``midi_messages`` must be
+        a Python ``List`` containing one of the following types:
+
+         - Objects with a ``bytes()`` method and ``time`` property (such as :doc:`mido:messages`
+           from :doc:`mido:index`, not included with Pedalboard)
+         - Tuples that look like: ``(midi_bytes: bytes, timestamp_in_seconds: float)``
+         - Tuples that look like: ``(midi_bytes: List[int], timestamp_in_seconds: float)``
+
+        The returned array will contain ``duration`` seconds worth of audio at the
+        provided ``sample_rate``.
+
+        Each MIDI message will be sent to the plugin at its
+        timestamp, where a timestamp of ``0`` indicates the start of the buffer, and
+        a timestamp equal to ``duration`` indicates the end of the buffer. (Any MIDI
+        messages whose timestamps are greater than ``duration`` will be ignored.)
+
+        The provided ``buffer_size`` argument will be used to control the size of
+        each chunk of audio returned by the plugin at once. Higher buffer sizes may
+        speed up processing, but may cause increased memory usage.
+
+        The ``reset`` flag determines if this plugin should be reset before
+        processing begins, clearing any state from previous calls to ``process``.
+        If calling ``process`` multiple times while processing the same audio or
+        MIDI stream, set ``reset`` to ``False``.
+
+        .. note::
+            The :py:meth:`process` method can also be used via :py:meth:`__call__`;
+            i.e.: just calling this object like a function (``my_plugin(...)``) will
+            automatically invoke :py:meth:`process` with the same arguments.
+
+
+        Examples
+        --------
+
+        Running audio through an external effect plugin::
+
+           from pedalboard import load_plugin
+           from pedalboard.io import AudioFile
+
+           plugin = load_plugin("../path-to-my-plugin-file")
+           assert plugin.is_effect
+           with AudioFile("input-audio.wav") as f:
+               output_audio = plugin(f.read(), f.samplerate)
+
+
+        Rendering MIDI via an external instrument plugin::
+
+           from pedalboard import load_plugin
+           from pedalboard.io import AudioFile
+           from mido import Message # not part of Pedalboard, but convenient!
+
+           plugin = load_plugin("../path-to-my-plugin-file")
+           assert plugin.is_instrument
+
+           sample_rate = 44100
+           num_channels = 2
+           with AudioFile("output-audio.wav", "w", sample_rate, num_channels) as f:
+               f.write(plugin(
+                   [Message("note_on", note=60), Message("note_off", note=60, time=4)],
+                   sample_rate=sample_rate,
+                   duration=5,
+                   num_channels=num_channels
+               ))
+
+
+        *Support for instrument plugins introduced in v0.7.4.*
+
+
+
+        Pass a buffer of audio (as a 32- or 64-bit NumPy array) *or* a list of
+        MIDI messages to this plugin, returning audio.
+
+        (If calling this multiple times with multiple effect plugins, consider
+        creating a :class:`pedalboard.Pedalboard` object instead.)
+
+        When provided audio as input, the returned array may contain up to (but not
+        more than) the same number of samples as were provided. If fewer samples
+        were returned than expected, the plugin has likely buffered audio inside
+        itself. To receive the remaining audio, pass another audio buffer into
+        ``process`` with ``reset`` set to ``True``.
+
+        If the provided buffer uses a 64-bit datatype, it will be converted to 32-bit
+        for processing.
+
+        If provided MIDI messages as input, the provided ``midi_messages`` must be
+        a Python ``List`` containing one of the following types:
+
+         - Objects with a ``bytes()`` method and ``time`` property (such as :doc:`mido:messages`
+           from :doc:`mido:index`, not included with Pedalboard)
+         - Tuples that look like: ``(midi_bytes: bytes, timestamp_in_seconds: float)``
+         - Tuples that look like: ``(midi_bytes: List[int], timestamp_in_seconds: float)``
+
+        The returned array will contain ``duration`` seconds worth of audio at the
+        provided ``sample_rate``.
+
+        Each MIDI message will be sent to the plugin at its
+        timestamp, where a timestamp of ``0`` indicates the start of the buffer, and
+        a timestamp equal to ``duration`` indicates the end of the buffer. (Any MIDI
+        messages whose timestamps are greater than ``duration`` will be ignored.)
+
+        The provided ``buffer_size`` argument will be used to control the size of
+        each chunk of audio returned by the plugin at once. Higher buffer sizes may
+        speed up processing, but may cause increased memory usage.
+
+        The ``reset`` flag determines if this plugin should be reset before
+        processing begins, clearing any state from previous calls to ``process``.
+        If calling ``process`` multiple times while processing the same audio or
+        MIDI stream, set ``reset`` to ``False``.
+
+        .. note::
+            The :py:meth:`process` method can also be used via :py:meth:`__call__`;
+            i.e.: just calling this object like a function (``my_plugin(...)``) will
+            automatically invoke :py:meth:`process` with the same arguments.
+
+
+        Examples
+        --------
+
+        Running audio through an external effect plugin::
+
+           from pedalboard import load_plugin
+           from pedalboard.io import AudioFile
+
+           plugin = load_plugin("../path-to-my-plugin-file")
+           assert plugin.is_effect
+           with AudioFile("input-audio.wav") as f:
+               output_audio = plugin(f.read(), f.samplerate)
+
+
+        Rendering MIDI via an external instrument plugin::
+
+           from pedalboard import load_plugin
+           from pedalboard.io import AudioFile
+           from mido import Message # not part of Pedalboard, but convenient!
+
+           plugin = load_plugin("../path-to-my-plugin-file")
+           assert plugin.is_instrument
+
+           sample_rate = 44100
+           num_channels = 2
+           with AudioFile("output-audio.wav", "w", sample_rate, num_channels) as f:
+               f.write(plugin(
+                   [Message("note_on", note=60), Message("note_off", note=60, time=4)],
+                   sample_rate=sample_rate,
+                   duration=5,
+                   num_channels=num_channels
+               ))
+
+
+        *Support for instrument plugins introduced in v0.7.4.*
+
+        """
+    @typing.overload
+    def process(
+        self,
+        midi_messages: object,
+        duration: float,
+        sample_rate: float,
+        num_channels: int = 2,
+        buffer_size: int = 8192,
+        reset: bool = True,
+    ) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]: ...
+    def show_editor(self) -> None:
+        """
+        Show the UI of this plugin as a native window. This method will block until the window is closed or a KeyboardInterrupt is received.
+        """
+    @property
+    def _parameters(self) -> typing.List[_AudioProcessorParameter]:
+        """ """
+    @property
+    def name(self) -> str:
+        """
+        The name of this plugin.
+
+
+        """
+    pass
+
 class _AudioProcessorParameter:
     """
     An abstract base class for parameter objects that can be added to an AudioProcessor.
     """
 
     def __repr__(self) -> str: ...
     def get_name(self, maximum_string_length: int) -> str:
@@ -937,82 +1703,14 @@
         """
         Returns the current value of the parameter as a string.
 
 
         """
     pass
 
-class _AudioUnitPlugin(ExternalPlugin, Plugin):
-    """
-    A wrapper around any Apple Audio Unit audio effect plugin. Only available on macOS.
-    """
-
-    def __init__(
-        self, path_to_plugin_file: str, plugin_name: typing.Optional[str] = None
-    ) -> None: ...
-    def __repr__(self) -> str: ...
-    def _get_parameter(self, arg0: str) -> _AudioProcessorParameter: ...
-    @staticmethod
-    def get_plugin_names_for_file(filename: str) -> typing.List[str]:
-        """
-        Return a list of plugin names contained within a given Audio Unit bundle (i.e.: a ``.component`` file). If the provided file cannot be scanned, an ``ImportError`` will be raised.
-
-        Note that most Audio Units have a single plugin inside, but this method can be useful to determine if multiple plugins are present in one bundle, and if so, what their names are.
-        """
-    def show_editor(self) -> None:
-        """
-        Show the UI of this plugin as a native window. This method will block until the window is closed or a KeyboardInterrupt is received.
-        """
-    @property
-    def _parameters(self) -> typing.List[_AudioProcessorParameter]:
-        """ """
-    @property
-    def name(self) -> str:
-        """
-        The name of this plugin, as reported by the plugin itself.
-
-
-        """
-    pass
-
-class _VST3Plugin(ExternalPlugin, Plugin):
-    """
-    A wrapper around any Steinberg® VST3 audio effect plugin. Note that plugins must already support the operating system currently in use (i.e.: if you're running Linux but trying to open a VST that does not support Linux, this will fail).
-    """
-
-    def __init__(
-        self, path_to_plugin_file: str, plugin_name: typing.Optional[str] = None
-    ) -> None: ...
-    def __repr__(self) -> str: ...
-    def _get_parameter(self, arg0: str) -> _AudioProcessorParameter: ...
-    @staticmethod
-    def get_plugin_names_for_file(arg0: str) -> typing.List[str]:
-        """
-        Return a list of plugin names contained within a given VST3 plugin (i.e.: a ".vst3"). If the provided file cannot be scanned, an ImportError will be raised.
-        """
-    def load_preset(self, preset_file_path: str) -> None:
-        """
-        Load a VST3 preset file in .vstpreset format.
-        """
-    def show_editor(self) -> None:
-        """
-        Show the UI of this plugin as a native window. This method will block until the window is closed or a KeyboardInterrupt is received.
-        """
-    @property
-    def _parameters(self) -> typing.List[_AudioProcessorParameter]:
-        """ """
-    @property
-    def name(self) -> str:
-        """
-        The name of this plugin.
-
-
-        """
-    pass
-
 def process(
     input_array: numpy.ndarray,
     sample_rate: float,
     plugins: typing.List[Plugin],
     buffer_size: int = 8192,
     reset: bool = True,
 ) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]:
```

## pedalboard_native/_internal/__init__.pyi

```diff
@@ -1,10 +1,31 @@
 from __future__ import annotations
 import pedalboard_native._internal
+
 import typing
+
+original_overload = typing.overload
+__OVERLOADED_DOCSTRINGS = {}
+
+def patch_overload(func):
+    original_overload(func)
+    if func.__doc__:
+        __OVERLOADED_DOCSTRINGS[func.__qualname__] = func.__doc__
+    else:
+        func.__doc__ = __OVERLOADED_DOCSTRINGS.get(func.__qualname__)
+    if func.__doc__:
+        # Work around the fact that pybind11-stubgen generates
+        # duplicate docstrings sometimes, once for each overload:
+        docstring = func.__doc__
+        if docstring[len(docstring) // 2 :].strip() == docstring[: -len(docstring) // 2].strip():
+            func.__doc__ = docstring[len(docstring) // 2 :].strip()
+    return func
+
+typing.overload = patch_overload
+
 from typing_extensions import Literal
 from enum import Enum
 import pedalboard_native
 
 __all__ = [
     "AddLatency",
     "FixedSizeBlockTestPlugin",
```

## pedalboard_native/io/__init__.pyi

```diff
@@ -1,13 +1,34 @@
 """This module provides classes and functions for reading and writing audio files or streams.
 
 *Introduced in v0.5.1.*"""
 from __future__ import annotations
 import pedalboard_native.io
+
 import typing
+
+original_overload = typing.overload
+__OVERLOADED_DOCSTRINGS = {}
+
+def patch_overload(func):
+    original_overload(func)
+    if func.__doc__:
+        __OVERLOADED_DOCSTRINGS[func.__qualname__] = func.__doc__
+    else:
+        func.__doc__ = __OVERLOADED_DOCSTRINGS.get(func.__qualname__)
+    if func.__doc__:
+        # Work around the fact that pybind11-stubgen generates
+        # duplicate docstrings sometimes, once for each overload:
+        docstring = func.__doc__
+        if docstring[len(docstring) // 2 :].strip() == docstring[: -len(docstring) // 2].strip():
+            func.__doc__ = docstring[len(docstring) // 2 :].strip()
+    return func
+
+typing.overload = patch_overload
+
 from typing_extensions import Literal
 from enum import Enum
 import numpy
 import pedalboard_native.utils
 
 _Shape = typing.Tuple[int, ...]
 
@@ -212,30 +233,15 @@
         self,
         input_device_name: str,
         output_device_name: str,
         plugins: typing.Optional[pedalboard_native.utils.Chain] = None,
         sample_rate: typing.Optional[float] = None,
         buffer_size: int = 512,
         allow_feedback: bool = False,
-    ) -> None:
-        """
-        Create a new :class:`AudioStream` instance.
-
-        Creating this object does not start an audio stream; it merely prepares
-        the stream to run.
-
-        Use the :py:meth:`input_device_names` and :py:meth:`output_device_names`
-        properties to fetch the currently-available input and output device names
-        on the current system.
-
-        Note that if the provided input device name looks like a microphone and
-        the provided output device name looks like a speaker, this constructor will
-        throw an exception to prevent audio feedback from occurring. To bypass this,
-        pass ``allow_feedback=True`` (and ensure your volume is turned down!).
-        """
+    ) -> None: ...
     def __repr__(self) -> str: ...
     def run(self) -> None:
         """
         Start streaming audio from input to output, passing the audio stream  through the :py:attr:`plugins` on this AudioStream object. This call will block the current thread until a :py:exc:`KeyboardInterrupt` (``Ctrl-C``) is received.
         """
     @property
     def plugins(self) -> pedalboard_native.utils.Chain:
@@ -252,16 +258,17 @@
     @property
     def running(self) -> bool:
         """
         :py:const:`True` if this stream is currently streaming live audio from input to output, :py:const:`False` otherwise.
 
 
         """
-    input_device_names: typing.List[str]
-    output_device_names: typing.List[str]
+    input_device_names: typing.List[str] = []
+    output_device_names: typing.List[str] = []
+    pass
 
 class ReadableAudioFile(AudioFile):
     """
     A class that wraps an audio file for reading, with native support for Ogg Vorbis,
     MP3, WAV, FLAC, and AIFF files on all operating systems. Other formats may also
     be readable depending on the operating system and installed system libraries:
```

## pedalboard_native/utils/__init__.pyi

```diff
@@ -1,10 +1,31 @@
 from __future__ import annotations
 import pedalboard_native.utils
+
 import typing
+
+original_overload = typing.overload
+__OVERLOADED_DOCSTRINGS = {}
+
+def patch_overload(func):
+    original_overload(func)
+    if func.__doc__:
+        __OVERLOADED_DOCSTRINGS[func.__qualname__] = func.__doc__
+    else:
+        func.__doc__ = __OVERLOADED_DOCSTRINGS.get(func.__qualname__)
+    if func.__doc__:
+        # Work around the fact that pybind11-stubgen generates
+        # duplicate docstrings sometimes, once for each overload:
+        docstring = func.__doc__
+        if docstring[len(docstring) // 2 :].strip() == docstring[: -len(docstring) // 2].strip():
+            func.__doc__ = docstring[len(docstring) // 2 :].strip()
+    return func
+
+typing.overload = patch_overload
+
 from typing_extensions import Literal
 from enum import Enum
 import pedalboard_native
 
 __all__ = ["Chain", "Mix"]
 
 class Chain(pedalboard_native.PluginContainer, pedalboard_native.Plugin):
```

## Comparing `pedalboard-0.7.3.dist-info/LICENSE` & `pedalboard-0.7.4.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `pedalboard-0.7.3.dist-info/METADATA` & `pedalboard-0.7.4.dist-info/METADATA`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pedalboard
-Version: 0.7.3
+Version: 0.7.4
 Summary: A Python library for adding effects to audio.
 Author: Peter Sobot
 Author-email: psobot@spotify.com
 Classifier: Development Status :: 4 - Beta
 Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
 Classifier: Operating System :: MacOS
 Classifier: Operating System :: Microsoft :: Windows
@@ -31,17 +31,19 @@
 [![PyPI - Python Version](https://img.shields.io/pypi/pyversions/pedalboard)](https://pypi.org/project/pedalboard)
 [![Supported Platforms](https://img.shields.io/badge/platforms-macOS%20%7C%20Windows%20%7C%20Linux-green)](https://pypi.org/project/pedalboard)
 [![Apple Silicon support for macOS and Linux (Docker)](https://img.shields.io/badge/Apple%20Silicon-macOS%20and%20Linux-brightgreen)](https://pypi.org/project/pedalboard)
 [![PyPI - Wheel](https://img.shields.io/pypi/wheel/pedalboard)](https://pypi.org/project/pedalboard)
 [![Test Badge](https://github.com/spotify/pedalboard/actions/workflows/all.yml/badge.svg)](https://github.com/spotify/pedalboard/actions/workflows/all.yml)
 [![Coverage Badge](https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/psobot/8736467e9952991ef44a67915ee7c762/raw/coverage.json)](https://gist.githubusercontent.com/psobot/8736467e9952991ef44a67915ee7c762/raw/coverage.json)
 [![PyPI - Downloads](https://img.shields.io/pypi/dm/pedalboard)](https://pypistats.org/packages/pedalboard)
+[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.7817838.svg)](https://doi.org/10.5281/zenodo.7817838)
 [![GitHub Repo stars](https://img.shields.io/github/stars/spotify/pedalboard?style=social)](https://github.com/spotify/pedalboard/stargazers)
 
-`pedalboard` is a Python library for working with audio: reading, writing, adding effects, and more. It supports most popular audio file formats and a number of common audio effects out of the box, and also allows the use of [VST3®](https://www.steinberg.net/en/company/technologies/vst3.html) and [Audio Unit](https://en.wikipedia.org/wiki/Audio_Units) formats for third-party plugins.
+
+`pedalboard` is a Python library for working with audio: reading, writing, rendering, adding effects, and more. It supports most popular audio file formats and a number of common audio effects out of the box, and also allows the use of [VST3®](https://www.steinberg.net/en/company/technologies/vst3.html) and [Audio Unit](https://en.wikipedia.org/wiki/Audio_Units) formats for loading third-party software instruments and effects.
 
 `pedalboard` was built by [Spotify's Audio Intelligence Lab](https://research.atspotify.com/audio-intelligence/) to enable using studio-quality audio effects from within Python and TensorFlow. Internally at Spotify, `pedalboard` is used for [data augmentation](https://en.wikipedia.org/wiki/Data_augmentation) to improve machine learning models and to help power features like [Spotify's AI DJ](https://newsroom.spotify.com/2023-02-22/spotify-debuts-a-new-ai-dj-right-in-your-pocket/). `pedalboard` also helps in the process of content creation, making it possible to add effects to audio without using a Digital Audio Workstation.
 
 [![Documentation](https://img.shields.io/badge/Documentation-on%20github.io-brightgreen)](https://spotify.github.io/pedalboard)
 
 ## Features 
 
@@ -54,16 +56,16 @@
    - Guitar-style effects: `Chorus`, `Distortion`, `Phaser`, `Clipping`
    - Loudness and dynamic range effects: `Compressor`, `Gain`, `Limiter`
    - Equalizers and filters: `HighpassFilter`, `LadderFilter`, `LowpassFilter`
    - Spatial effects: `Convolution`, `Delay`, `Reverb`
    - Pitch effects: `PitchShift`
    - Lossy compression: `GSMFullRateCompressor`, `MP3Compressor`
    - Quality reduction: `Resample`, `Bitcrush`
- - Supports VST3® plugins on macOS, Windows, and Linux ([`pedalboard.load_plugin`](https://spotify.github.io/pedalboard/reference/pedalboard.html#pedalboard.load_plugin))
- - Supports Audio Units on macOS
+ - Supports VST3® instrument and effect plugins on macOS, Windows, and Linux ([`pedalboard.load_plugin`](https://spotify.github.io/pedalboard/reference/pedalboard.html#pedalboard.load_plugin))
+ - Supports instrument and effect Audio Units on macOS
  - Strong thread-safety, memory usage, and speed guarantees
    - Releases Python's Global Interpreter Lock (GIL) to allow use of multiple CPU cores
      - No need to use `multiprocessing`!
    - Even when only using one thread:
      - Processes audio up to **300x** faster than [pySoX](https://github.com/rabitt/pysox) for single transforms, and 2-5x faster than [SoxBindings](https://github.com/pseeth/soxbindings) (via [iCorv](https://github.com/iCorv/pedalboard_with_tfdata))
      - Reads audio files up to **4x** faster than [librosa.load](https://librosa.org/doc/main/generated/librosa.load.html) (in many cases)
  - Tested compatibility with TensorFlow - can be used in `tf.data` pipelines!
@@ -165,42 +167,49 @@
 effected = board(audio, samplerate)
 
 # Write the audio back as a wav file:
 with AudioFile('processed-output.wav', 'w', samplerate, effected.shape[0]) as f:
   f.write(effected)
 ```
 
-### Using VST3® or Audio Unit plugins
+### Using VST3® or Audio Unit instrument and effect plugins
 
 ```python
 from pedalboard import Pedalboard, Reverb, load_plugin
 from pedalboard.io import AudioFile
+from mido import Message # not part of Pedalboard, but convenient!
 
 # Load a VST3 or Audio Unit plugin from a known path on disk:
-vst = load_plugin("./VSTs/RoughRider3.vst3")
+instrument = load_plugin("./VSTs/Magical8BitPlug2.vst3")
+effect = load_plugin("./VSTs/RoughRider3.vst3")
 
-print(vst.parameters.keys())
+print(effect.parameters.keys())
 # dict_keys([
 #   'sc_hpf_hz', 'input_lvl_db', 'sensitivity_db',
 #   'ratio', 'attack_ms', 'release_ms', 'makeup_db',
 #   'mix', 'output_lvl_db', 'sc_active',
 #   'full_bandwidth', 'bypass', 'program',
 # ])
 
 # Set the "ratio" parameter to 15
-vst.ratio = 15
+effect.ratio = 15
 
-# Use this VST to process some audio:
-with AudioFile('some-file.wav', 'r') as f:
-  audio = f.read(f.frames)
-  samplerate = f.samplerate
-effected = vst(audio, samplerate)
+# Render some audio by passing MIDI to an instrument:
+samplerate = 44100
+audio = instrument(
+  [Message("note_on", note=60), Message("note_off", note=60, time=5)],
+  samplerate,
+  duration=5, # seconds
+)
 
-# ...or put this VST into a chain with other plugins:
-board = Pedalboard([vst, Reverb()])
+# Apply effects to this audio:
+effected = effect(audio, samplerate)
+
+# ...or put the effect into a chain with other plugins:
+board = Pedalboard([effect, Reverb()])
 # ...and run that pedalboard with the same VST instance!
 effected = board(audio, samplerate)
 ```
 
 ### Creating parallel effects chains
 
 This example creates a delayed pitch-shift effect by running
@@ -274,16 +283,34 @@
  - [_Working with Audio in Python (feat. Pedalboard)_ by Peter Sobot at EuroPython 2022](https://www.youtube.com/watch?v=NYhkqXpFAlg)
  - [an interactive web demo on Hugging Face Spaces and Gradio](https://huggingface.co/spaces/akhaliq/pedalboard) (via [@AK391](https://github.com/AK391)) 
 
 ## Contributing
 
 Contributions to `pedalboard` are welcomed! See [CONTRIBUTING.md](https://github.com/spotify/pedalboard/blob/master/CONTRIBUTING.md) for details.
 
+## Citing
+
+To cite `pedalboard` in academic work, use [its entry on Zenodo](https://doi.org/10.5281/zenodo.7817838): [![DOI 7817838](https://zenodo.org/badge/DOI/10.5281/zenodo.7817838.svg)](https://doi.org/10.5281/zenodo.7817838)
+
+To cite via BibTeX:
+
+```tex
+@software{sobot_peter_2023_7817838,
+  author       = {Sobot, Peter},
+  title        = {Pedalboard},
+  month        = jul,
+  year         = 2021,
+  publisher    = {Zenodo},
+  doi          = {10.5281/zenodo.7817838},
+  url          = {https://doi.org/10.5281/zenodo.7817838}
+}
+```
+
 ## License
-`pedalboard` is Copyright 2021-2022 Spotify AB.
+`pedalboard` is Copyright 2021-2023 Spotify AB.
 
 `pedalboard` is licensed under the [GNU General Public License v3](https://www.gnu.org/licenses/gpl-3.0.en.html). `pedalboard` includes a number of libraries that are statically compiled, and which carry the following licenses:
 
  - The core audio processing code is pulled from [JUCE 6](https://juce.com/), which is [dual-licensed under a commercial license and the GPLv3](https://juce.com/juce-6-licence).
  - The [VST3 SDK](https://github.com/steinbergmedia/vst3sdk), bundled with JUCE, is owned by [Steinberg® Media Technologies GmbH](https://www.steinberg.net/en/home.html) and licensed under the GPLv3.
  - The `PitchShift` plugin uses [the Rubber Band Library](https://github.com/breakfastquay/rubberband), which is [dual-licensed under a commercial license](https://breakfastquay.com/technology/license.html) and the GPLv2 (or newer).
  - The `MP3Compressor` plugin uses [libmp3lame from the LAME project](https://lame.sourceforge.io/), which is [licensed under the LGPLv2](https://github.com/lameproject/lame/blob/master/README) and [upgraded to the GPLv3 for inclusion in this project (as permitted by the LGPLv2)](https://www.gnu.org/licenses/gpl-faq.html#AllCompatibility).
```

## Comparing `pedalboard-0.7.3.dist-info/NOTICE` & `pedalboard-0.7.4.dist-info/NOTICE`

 * *Files identical despite different names*

## Comparing `pedalboard-0.7.3.dist-info/RECORD` & `pedalboard-0.7.4.dist-info/RECORD`

 * *Files 19% similar despite different names*

```diff
@@ -1,16 +1,17 @@
-pedalboard_native.pypy39-pp73-win_amd64.pyd,sha256=e5ESQp6U-g2zO67dbS0dGmkXrFXXshcrRk0U-8v6AHw,7315456
+pedalboard_native.pypy39-pp73-win_amd64.pyd,sha256=EqvFSEmhePvbqw-oCt1aeE7SBNPbM_v2xqShYaET-Hk,7351808
 pedalboard/__init__.py,sha256=Q7p0cQU5noDsbB5zsXI41W8kstP8Zwu1hY0AYSvXipc,1917
-pedalboard/_pedalboard.py,sha256=d-_sKESw5-5ymaxlF21QA-peqU8f0kDi8XMFHfbwDMM,34106
+pedalboard/_pedalboard.py,sha256=s7eBQLEs_aRbL3defYMBwm6i4r8y6twXsDgoYR0loLE,32061
+pedalboard/midi_utils.py,sha256=tKRj9AujvV0K-YfoiPPduYNMTS_PInH1GOOJ-JL8JLc,3527
 pedalboard/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-pedalboard/version.py,sha256=yv2D-aC6PNKsBenUSmjU9oTEmbH-MASJ0S0VSQEiVcQ,705
+pedalboard/version.py,sha256=7LRgJccM2BNoqN7YZakgaimeNyYmORn83S1gIphBAuM,705
 pedalboard/io/__init__.py,sha256=bE2o4g2VYxi1zuLbRt6rcEa-ENsEJya_XUAdBDu38VI,478
-pedalboard_native/__init__.pyi,sha256=4PsHsnAQdJUVbkj5m6XpkWngr1bBLwAhvb600OCgtz8,35658
-pedalboard_native/_internal/__init__.pyi,sha256=StyGiwxqGVNL7n2X-l_pZvTRWK8yBqK2vTBo8OLvfn0,1878
-pedalboard_native/io/__init__.pyi,sha256=1KTCmCR3b8OTfKn91fS5AQj1xNUL7a0a6IoCTJrA-h0,38738
-pedalboard_native/utils/__init__.pyi,sha256=K11N0B48Levbipb5cLjJArFRnDSquSySgtwhLrhqAJM,937
-pedalboard-0.7.3.dist-info/LICENSE,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
-pedalboard-0.7.3.dist-info/METADATA,sha256=1aNtMDpLsKPb7_77ql6_8awbsbRgj0bOsR9m3TTE-qE,14623
-pedalboard-0.7.3.dist-info/NOTICE,sha256=kiwgiOynSFva5dva9jbBupGHmrxihaxbDWAsJNGZzls,589
-pedalboard-0.7.3.dist-info/WHEEL,sha256=QQY0XPJVcbNrDwRnZBTwtxGbMWJnHaWRpMJLfPEPCFM,107
-pedalboard-0.7.3.dist-info/top_level.txt,sha256=jXwDvqMjquuPLra-PGmmayt3AFe5_l7hpSqbUgOvP9g,29
-pedalboard-0.7.3.dist-info/RECORD,,
+pedalboard_native/__init__.pyi,sha256=3ET-VsGk2ImLTJXB_KsGQ42wDsgxBjmRG-n8czUv01Y,64646
+pedalboard_native/_internal/__init__.pyi,sha256=61KHyN3rGg3JuH6eZx7QVwf_EJin6KIyK5yBwOKkaMg,2588
+pedalboard_native/io/__init__.pyi,sha256=-DbmWO1p_o-S9hBA2w3_WvQ9ik8663u5eHB97xzRtTU,38749
+pedalboard_native/utils/__init__.pyi,sha256=3R6Fd0rFZo7rGc97AETjz6LjaCA6OnVsvqnh9t7GwfA,1647
+pedalboard-0.7.4.dist-info/LICENSE,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
+pedalboard-0.7.4.dist-info/METADATA,sha256=gnABiGRhW_1gb4TrJB-AddYkmmCztEApnSj0yCna5Nw,15648
+pedalboard-0.7.4.dist-info/NOTICE,sha256=kiwgiOynSFva5dva9jbBupGHmrxihaxbDWAsJNGZzls,589
+pedalboard-0.7.4.dist-info/WHEEL,sha256=QQY0XPJVcbNrDwRnZBTwtxGbMWJnHaWRpMJLfPEPCFM,107
+pedalboard-0.7.4.dist-info/top_level.txt,sha256=jXwDvqMjquuPLra-PGmmayt3AFe5_l7hpSqbUgOvP9g,29
+pedalboard-0.7.4.dist-info/RECORD,,
```

