# Comparing `tmp/odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.0-py3-none-any.whl.zip` & `tmp/odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.1.dev5-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,32 +1,33 @@
-Zip file size: 194351 bytes, number of entries: 30
--rw-r--r--  2.0 unx     4224 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/README.rst
--rw-r--r--  2.0 unx       57 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/__init__.py
--rw-r--r--  2.0 unx      631 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/__manifest__.py
--rw-r--r--  2.0 unx      385 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/hooks.py
--rw-r--r--  2.0 unx      606 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/data/shopfloor_scenario_data.xml
--rw-r--r--  2.0 unx      743 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/demo/shopfloor_menu_demo.xml
--rw-r--r--  2.0 unx      989 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/demo/stock_picking_type_demo.xml
--rw-r--r--  2.0 unx     3965 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/docs/diagram.plantuml
--rw-r--r--  2.0 unx   172886 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/docs/diagram.png
--rw-r--r--  2.0 unx     3297 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/docs/oca_logo.png
--rw-r--r--  2.0 unx      784 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/i18n/shopfloor_single_product_transfer.pot
--rw-r--r--  2.0 unx      438 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/migrations/14.0.1.1.0/post-migrate.py
--rw-r--r--  2.0 unx       58 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/readme/CONTRIBUTORS.rst
--rw-r--r--  2.0 unx       63 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/readme/DESCRIPTION.rst
--rw-r--r--  2.0 unx     1274 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/readme/USAGE.rst
--rw-r--r--  2.0 unx       38 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/services/__init__.py
--rw-r--r--  2.0 unx    31235 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/services/single_product_transfer.py
--rw-r--r--  2.0 unx     9455 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/static/description/icon.png
--rw-r--r--  2.0 unx    13699 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/static/description/index.html
--rw-r--r--  2.0 unx      168 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/tests/__init__.py
--rw-r--r--  2.0 unx     4433 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/tests/common.py
--rw-r--r--  2.0 unx     1863 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/tests/test_scan_location.py
--rw-r--r--  2.0 unx    22837 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/tests/test_scan_product.py
--rw-r--r--  2.0 unx    23165 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/tests/test_set_quantity.py
--rw-r--r--  2.0 unx     3712 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/tests/test_set_quantity_checkout_sync.py
--rw-r--r--  2.0 unx     1081 b- defN 23-May-26 15:38 odoo/addons/shopfloor_single_product_transfer/tests/test_start.py
--rw-r--r--  2.0 unx     4827 b- defN 23-May-26 15:38 odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-26 15:38 odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.0.dist-info/WHEEL
--rw-r--r--  2.0 unx        5 b- defN 23-May-26 15:38 odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3752 b- defN 23-May-26 15:38 odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.0.dist-info/RECORD
-30 files, 310762 bytes uncompressed, 187827 bytes compressed:  39.6%
+Zip file size: 197356 bytes, number of entries: 31
+-rw-r--r--  2.0 unx     4224 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/README.rst
+-rw-r--r--  2.0 unx       57 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/__init__.py
+-rw-r--r--  2.0 unx      631 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/__manifest__.py
+-rw-r--r--  2.0 unx      385 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/hooks.py
+-rw-r--r--  2.0 unx      606 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/data/shopfloor_scenario_data.xml
+-rw-r--r--  2.0 unx      743 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/demo/shopfloor_menu_demo.xml
+-rw-r--r--  2.0 unx      989 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/demo/stock_picking_type_demo.xml
+-rw-r--r--  2.0 unx     3965 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/docs/diagram.plantuml
+-rw-r--r--  2.0 unx   172886 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/docs/diagram.png
+-rw-r--r--  2.0 unx     3297 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/docs/oca_logo.png
+-rw-r--r--  2.0 unx      784 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/i18n/shopfloor_single_product_transfer.pot
+-rw-r--r--  2.0 unx      438 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/migrations/14.0.1.1.0/post-migrate.py
+-rw-r--r--  2.0 unx       58 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/readme/CONTRIBUTORS.rst
+-rw-r--r--  2.0 unx       63 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/readme/DESCRIPTION.rst
+-rw-r--r--  2.0 unx     1274 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/readme/USAGE.rst
+-rw-r--r--  2.0 unx       38 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/services/__init__.py
+-rw-r--r--  2.0 unx    40376 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/services/single_product_transfer.py
+-rw-r--r--  2.0 unx     9455 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/static/description/icon.png
+-rw-r--r--  2.0 unx    13699 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/static/description/index.html
+-rw-r--r--  2.0 unx      211 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/tests/__init__.py
+-rw-r--r--  2.0 unx     4518 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/tests/common.py
+-rw-r--r--  2.0 unx     4072 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/tests/test_scan_location_or_package.py
+-rw-r--r--  2.0 unx    22848 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/tests/test_scan_product.py
+-rw-r--r--  2.0 unx     2569 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/tests/test_set_location.py
+-rw-r--r--  2.0 unx    25549 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/tests/test_set_quantity.py
+-rw-r--r--  2.0 unx     3712 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/tests/test_set_quantity_checkout_sync.py
+-rw-r--r--  2.0 unx     1092 b- defN 23-Jun-15 15:11 odoo/addons/shopfloor_single_product_transfer/tests/test_start.py
+-rw-r--r--  2.0 unx     4832 b- defN 23-Jun-15 15:11 odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.1.dev5.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-15 15:11 odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.1.dev5.dist-info/WHEEL
+-rw-r--r--  2.0 unx        5 b- defN 23-Jun-15 15:11 odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.1.dev5.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     3912 b- defN 23-Jun-15 15:11 odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.1.dev5.dist-info/RECORD
+31 files, 327380 bytes uncompressed, 190550 bytes compressed:  41.8%
```

## zipnote {}

```diff
@@ -57,35 +57,38 @@
 
 Filename: odoo/addons/shopfloor_single_product_transfer/tests/__init__.py
 Comment: 
 
 Filename: odoo/addons/shopfloor_single_product_transfer/tests/common.py
 Comment: 
 
-Filename: odoo/addons/shopfloor_single_product_transfer/tests/test_scan_location.py
+Filename: odoo/addons/shopfloor_single_product_transfer/tests/test_scan_location_or_package.py
 Comment: 
 
 Filename: odoo/addons/shopfloor_single_product_transfer/tests/test_scan_product.py
 Comment: 
 
+Filename: odoo/addons/shopfloor_single_product_transfer/tests/test_set_location.py
+Comment: 
+
 Filename: odoo/addons/shopfloor_single_product_transfer/tests/test_set_quantity.py
 Comment: 
 
 Filename: odoo/addons/shopfloor_single_product_transfer/tests/test_set_quantity_checkout_sync.py
 Comment: 
 
 Filename: odoo/addons/shopfloor_single_product_transfer/tests/test_start.py
 Comment: 
 
-Filename: odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.0.dist-info/METADATA
+Filename: odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.1.dev5.dist-info/METADATA
 Comment: 
 
-Filename: odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.0.dist-info/WHEEL
+Filename: odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.1.dev5.dist-info/WHEEL
 Comment: 
 
-Filename: odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.0.dist-info/top_level.txt
+Filename: odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.1.dev5.dist-info/top_level.txt
 Comment: 
 
-Filename: odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.0.dist-info/RECORD
+Filename: odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.1.dev5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## odoo/addons/shopfloor_single_product_transfer/services/single_product_transfer.py

```diff
@@ -54,62 +54,104 @@
     _inherit = "base.shopfloor.process"
     _name = "shopfloor.single.product.transfer"
     _usage = "single_product_transfer"
     _description = __doc__
 
     # Responses
 
-    def _response_for_select_location(self, message=None):
-        return self._response(next_state="select_location", message=message)
+    def _response_for_select_location_or_package(self, message=None):
+        return self._response(next_state="select_location_or_package", message=message)
 
-    def _response_for_select_product(self, location, message=None, popup=None):
-        data = {"location": self.data.location(location)}
+    def _response_for_select_product(
+        self, location=None, package=None, message=None, popup=None
+    ):
+        data = {}
+        if location:
+            data["location"] = self.data.location(location)
+        if package:
+            data["package"] = self.data.package(package)
         return self._response(
             next_state="select_product", data=data, message=message, popup=popup
         )
 
     def _response_for_set_quantity(
         self, move_line, message=None, asking_confirmation=False
     ):
         data = {
             "move_line": self.data.move_line(move_line),
             "asking_confirmation": asking_confirmation,
         }
         return self._response(next_state="set_quantity", data=data, message=message)
 
+    def _response_for_set_location(self, move_line, package, message=None):
+        data = {
+            "move_line": self.data.move_line(move_line),
+            "package": self.data.package(package),
+        }
+        return self._response(next_state="set_location", data=data, message=message)
+
     # Handlers
 
-    def _scan_location__location_found(self, location):
+    def _scan_location__location_found(self, location, quants):
         """Check that the location exists."""
         if not location:
             message = self.msg_store.no_location_found()
-            return self._response_for_select_location(message=message)
+            return self._response_for_select_location_or_package(message=message)
 
-    def _scan_location__check_location(self, location):
+    def _scan_location__check_location(self, location, quants):
         """Check that `location` belongs to the source location of the operation type."""
-        locations = self.picking_types.default_location_src_id
-        child_locations = self.env["stock.location"].search(
-            [("id", "child_of", locations.ids)]
-        )
-        if location not in (locations | child_locations):
+        if not self.is_src_location_valid(location):
             message = self.msg_store.location_content_unable_to_transfer(location)
-            return self._response_for_select_location(message=message)
+            return self._response_for_select_location_or_package(message=message)
 
-    def _scan_location__check_stock(self, location):
-        """Check if the location has products to move."""
-        quants_in_location = self.env["stock.quant"].search(
-            [("location_id", "=", location.id), ("quantity", ">", 0)]
-        )
-        if not quants_in_location:
+    def _scan_location__check_stock(self, location, quants):
+        """Check that the location has products to move."""
+        if not quants:
             message = self.msg_store.location_empty(location)
-            return self._response_for_select_location(message=message)
+            return self._response_for_select_location_or_package(message=message)
 
-    def _scan_product__scan_packaging(self, location, barcode):
-        search = self._actions_for("search")
-        packaging = search.packaging_from_scan(barcode)
+    def _scan_location__check_stock_packages(self, location, quants):
+        """Check that there are quants without an assigned package."""
+        quant_packages = [quant.package_id for quant in quants]
+        if all(quant_packages):
+            message = self.msg_store.location_contains_only_packages_scan_one()
+            return self._response_for_select_location_or_package(message=message)
+
+    def _scan_location__check_line_packages(self, location, quants):
+        """Check that the location has lines without an assigned package."""
+        if not self.is_allow_move_create():
+            lines_without_package = self.env["stock.move.line"].search(
+                [
+                    ("location_id", "=", location.id),
+                    ("package_id", "=", False),
+                    ("state", "in", ["assigned", "partially_available"]),
+                    ("picking_id.picking_type_id", "in", self.picking_types.ids),
+                ]
+            )
+            if not lines_without_package:
+                message = self.msg_store.location_contains_only_packages_scan_one()
+                return self._response_for_select_location_or_package(message=message)
+
+    def _scan_package__check_location(self, package):
+        """Check if this package corresponds to any of the allowed locations."""
+        if package.location_id and not self.is_src_location_valid(package.location_id):
+            message = self.msg_store.package_not_allowed_in_src_location(
+                package.name, self.picking_types
+            )
+            return self._response_for_select_location_or_package(message=message)
+
+    def _scan_package__check_stock(self, package):
+        """Check if this package corresponds to any of the allowed locations."""
+        if not package.quant_ids:
+            message = self.msg_store.package_not_allowed_in_src_location(
+                package.name, self.picking_types
+            )
+            return self._response_for_select_location_or_package(message=message)
+
+    def _scan_product__scan_packaging(self, packaging, location=None, package=None):
         handlers = [
             self._scan_product__check_tracking,
             self._scan_product__select_move_line,
             # If no line is found, we might try to create one,
             # if allow_move_create is True
             self._scan_product__check_create_move_line,
             # First, try to create a move line with the available quantity
@@ -118,25 +160,24 @@
             # allow_unreserve_other_moves is enabled
             self._scan_product__unreserve_move_line,
             # Check again if there's some unreserved qty
             self._scan_product__create_move_line,
             # Then return a `no product available` error
             self._scan_product__no_stock_available,
         ]
-        if packaging:
-            product = packaging.product_id
-            response = self._use_handlers(
-                handlers, product, location, packaging=packaging
-            )
-            if response:
-                return response
+        product = packaging.product_id
+        return self._use_handlers(
+            handlers,
+            product,
+            location=location,
+            package=package,
+            packaging=packaging,
+        )
 
-    def _scan_product__scan_product(self, location, barcode):
-        search = self._actions_for("search")
-        product = search.product_from_scan(barcode)
+    def _scan_product__scan_product(self, product, location=None, package=None):
         handlers = [
             self._scan_product__check_tracking,
             self._scan_product__select_move_line,
             # If no line is found, we might try to create one,
             # if allow_move_create is True
             self._scan_product__check_create_move_line,
             # First, try to create a move line with the available quantity
@@ -145,43 +186,44 @@
             # allow_unreserve_other_moves is enabled
             self._scan_product__unreserve_move_line,
             # Check again if there's some unreserved qty
             self._scan_product__create_move_line,
             # Then return a `no product available` error
             self._scan_product__no_stock_available,
         ]
-        if product:
-            response = self._use_handlers(handlers, product, location)
-            if response:
-                return response
+        return self._use_handlers(handlers, product, location=location, package=package)
 
     def _scan_product__check_tracking(
-        self, product, location, lot=None, packaging=None
+        self, product, location=None, package=None, lot=None, packaging=None
     ):
         if product.tracking == "lot":
             message = self.msg_store.scan_lot_on_product_tracked_by_lot()
-            return self._response_for_select_product(location, message=message)
+            return self._response_for_select_product(
+                location=location, package=package, message=message
+            )
 
-    def _scan_product__select_move_line_domain(self, product, location, lot=None):
+    def _scan_product__select_move_line_domain(
+        self, product, location=None, package=None, lot=None
+    ):
         domain = [
-            ("location_id", "=", location.id),
             ("product_id", "=", product.id),
             ("state", "in", ("assigned", "partially_available")),
             ("picking_id.user_id", "in", (False, self.env.uid)),
             ("picking_id.picking_type_id", "in", self.picking_types.ids),
         ]
-        if lot:
-            lot_domain = [("lot_id", "=", lot.id)]
-            domain = AND([domain, lot_domain])
-        return domain
+        return self._add_location_package_lot_domain(
+            domain, location=location, package=package, lot=lot
+        )
 
     def _scan_product__select_move_line(
-        self, product, location, lot=None, packaging=None
+        self, product, location=None, package=None, lot=None, packaging=None
     ):
-        domain = self._scan_product__select_move_line_domain(product, location, lot=lot)
+        domain = self._scan_product__select_move_line_domain(
+            product, location=location, package=package, lot=lot
+        )
         query = self.env["stock.move.line"]._search(domain, limit=1)
         order_elems = [
             "stock_move_line__picking_id.user_id",
             "stock_move_line__picking_id.priority DESC",
             "stock_move_line__picking_id.scheduled_date ASC",
             "id DESC",
         ]
@@ -199,79 +241,98 @@
                     qty_done = packaging.qty
                 move_line.qty_done = qty_done
             else:
                 stock.mark_move_line_as_picked(move_line)
             return self._response_for_set_quantity(move_line)
 
     def _scan_product__check_create_move_line(
-        self, product, location, lot=None, packaging=None
+        self, product, location=None, package=None, lot=None, packaging=None
     ):
         if not self.is_allow_move_create():
             message = self.msg_store.no_operation_found()
-            return self._response_for_select_product(location, message=message)
+            return self._response_for_select_product(
+                location=location, package=package, message=message
+            )
 
     def _scan_product__unreserve_move_line(
-        self, product, location, lot=None, packaging=None
+        self, product, location=None, package=None, lot=None, packaging=None
     ):
         unreserve = self._actions_for("stock.unreserve")
         if self.work.menu.allow_unreserve_other_moves:
-            move_lines = self._find_location_move_lines(location, product, lot=lot)
+            move_lines = self._find_location_or_package_move_lines(
+                product, location=location, package=package, lot=lot
+            )
             response = unreserve.check_unreserve(location, move_lines, product, lot)
             if response:
                 return response
             unreserve.unreserve_moves(move_lines, self.picking_types)
         else:
             # If we get there then no qty is available, and we are not allowed to unreserve
             # other moves. No stock available for product.
             return self._scan_product__no_stock_available(
-                product, location, lot=lot, packaging=packaging
+                product,
+                location=location,
+                package=package,
+                lot=lot,
+                packaging=packaging,
             )
 
     def _scan_product__create_move_line(
-        self, product, location, lot=None, packaging=None
+        self, product, location=None, package=None, lot=None, packaging=None
     ):
+
         available_quantity = product.with_context(
-            location_id=location.id, lot=lot.id if lot else None
+            location=location.id if location else None,
+            package_id=package.id if package else None,
+            lot_id=lot.id if lot else None,
         ).free_qty
         is_product_available = (
             float_compare(
                 available_quantity,
                 packaging.qty if packaging else 1.0,
                 precision_rounding=product.uom_id.rounding,
             )
             >= 0
         )
         if is_product_available:
             move = self._create_move_from_location(
-                location, product, available_quantity, lot=lot, packaging=packaging
+                product,
+                available_quantity,
+                location=location,
+                package=package,
+                lot=lot,
+                packaging=packaging,
             )
             move_line = move.move_line_ids
             response = self._scan_product__check_putaway(move_line)
             if response:
                 return response
             return self._response_for_set_quantity(move_line)
 
     def _scan_product__no_stock_available(
-        self, product, location, lot=None, packaging=None
+        self, product, location=None, package=None, lot=None, packaging=None
     ):
         message = self.msg_store.no_operation_found()
-        return self._response_for_select_product(location, message=message)
+        return self._response_for_select_product(
+            location=location, package=package, message=message
+        )
 
     def _scan_product__check_putaway(self, move_line):
         stock = self._actions_for("stock")
         ignore_no_putaway_available = self.work.menu.ignore_no_putaway_available
         no_putaway_available = stock.no_putaway_available(self.picking_types, move_line)
         if ignore_no_putaway_available and no_putaway_available:
             message = self.msg_store.no_putaway_destination_available()
             return self._response_for_select_product(
-                move_line.location_id, message=message
+                location=move_line.location_id,
+                package=move_line.package_id,
+                message=message,
             )
 
-    def _scan_product__scan_lot(self, location, barcode):
-        search = self._actions_for("search")
+    def _scan_product__scan_lot(self, lot, location=None, package=None):
         handlers = [
             self._scan_product__select_move_line,
             # If no line is found, we might try to create one,
             # only if allow_move_create option is True
             self._scan_product__check_create_move_line,
             # First, try to create a move line with the available quantity
             self._scan_product__create_move_line,
@@ -279,67 +340,96 @@
             # allow_unreserve_other_moves is enabled
             self._scan_product__unreserve_move_line,
             # Check again if there's some unreserved qty
             self._scan_product__create_move_line,
             # Then return a `no product available` error
             self._scan_product__no_stock_available,
         ]
-        lot = search.lot_from_scan(barcode)
-        if lot:
-            product = lot.product_id
-            product_response = self._use_handlers(handlers, product, location, lot=lot)
-            if product_response:
-                return product_response
+        product = lot.product_id
+        product_response = self._use_handlers(
+            handlers, product, location=location, package=package, lot=lot
+        )
+        if product_response:
+            return product_response
 
     def _use_handlers(self, handlers, *args, **kwargs):
         # TODO: each handler should raise a Shopfloor dedicated exception
         # with the response data attached
         for handler in handlers:
             response = handler(*args, **kwargs)
             if response:
                 return response
 
+    def _add_location_package_lot_domain(
+        self, domain, location=None, package=None, lot=None
+    ):
+        if location:
+            domain = AND([domain, [("location_id", "=", location.id)]])
+        if lot:
+            domain = AND([domain, [("lot_id", "=", lot.id)]])
+        domain = AND([domain, [("package_id", "=", package.id if package else False)]])
+        return domain
+
     # Copied from manual_product_transfer
-    def _find_location_move_lines_domain(self, location, product, lot=None):
+    def _find_location_or_package_move_lines_domain(
+        self, product, location=None, package=None, lot=None
+    ):
         domain = [
-            ("location_id", "=", location.id),
             ("product_id", "=", product.id),
             ("state", "in", ("assigned", "partially_available")),
             ("picking_id.user_id", "in", (False, self.env.uid)),
         ]
-        if lot:
-            domain = AND([domain, [("lot_id", "=", lot.id)]])
-        return domain
+        return self._add_location_package_lot_domain(
+            domain, location=location, package=package, lot=lot
+        )
 
     # Copied from manual_product_transfer
-    def _find_location_move_lines(self, location, product, lot=None):
+    def _find_location_or_package_move_lines(
+        self, product, location=None, package=None, lot=None
+    ):
         """Find existing move lines in progress related to the source location
         but not linked to any user.
         """
-        domain = self._find_location_move_lines_domain(location, product, lot=lot)
+        domain = self._find_location_or_package_move_lines_domain(
+            product, location=location, package=package, lot=lot
+        )
         return self.env["stock.move.line"].search(domain)
 
     # Copied from manual_product_transfer
     def _create_move_from_location(
-        self, location, product, quantity, lot=None, packaging=None
+        self, product, quantity, location=None, package=None, lot=None, packaging=None
     ):
         picking_type = self.picking_types
+        location = location or package.location_id
         move_vals = {
             "name": product.name,
             "company_id": picking_type.company_id.id,
             "product_id": product.id,
             "product_uom": product.uom_id.id,
             "product_uom_qty": quantity,
             "location_id": location.id,
             "location_dest_id": picking_type.default_location_dest_id.id,
             "origin": self.work.menu.name,
             "picking_type_id": picking_type.id,
         }
         move = self.env["stock.move"].create(move_vals)
         move._action_confirm(merge=False)
+        picking = move.picking_id
+        if package:
+            # When we create a package_level, we force the reservation of the scanned package.
+            package_level = self.env["stock.package_level"].create(
+                {
+                    "picking_id": picking.id,
+                    "package_id": package.id,
+                    "location_id": package.location_id.id,
+                    "location_dest_id": picking.location_dest_id.id,
+                    "company_id": picking.company_id.id,
+                }
+            )
+            move.package_level_id = package_level
         move.with_context(
             {"force_reservation": self.work.menu.allow_force_reservation}
         )._action_assign()
         assert move.state == "assigned", "The reservation of quantities has failed"
         # we expect to get only one move line as we are
         # moving only bulk products w/o lot or package.
         move_line = move.move_line_ids[0]
@@ -360,22 +450,22 @@
     def _set_quantity__check_product_in_line(
         self, move_line, product, lot=None, packaging=None
     ):
         message = False
         if lot:
             wrong_lot = move_line.lot_id != lot
             if wrong_lot:
-                message = self.msg_store.wrong_record(lot._name)
+                message = self.msg_store.wrong_record(lot)
         if move_line.product_id != product:
-            message = self.msg_store.wrong_record(product._name)
+            message = self.msg_store.wrong_record(product)
         if message:
             return self._response_for_set_quantity(move_line, message=message)
 
     def _set_quantity__check_quantity_done(
-        self, location, move_line, confirmation=False
+        self, move_line, location=None, package=None, confirmation=False
     ):
         rounding = move_line.product_id.uom_id.rounding
         qty_done = move_line.qty_done
         qty_todo = move_line.product_uom_qty
         # If qty done is >= qty todo, then there's nothing more to pick
         if float_compare(qty_done, qty_todo, precision_rounding=rounding) > 0:
             message = self.msg_store.unable_to_pick_more(qty_todo)
@@ -408,44 +498,27 @@
 
     def _set_quantity__scan_product_handlers(self):
         return (
             self._set_quantity__check_product_in_line,
             self._set_quantity__increment_qty_done,
         )
 
-    def _set_quantity__scan_product(self, move_line, barcode, confirmation=False):
-        search = self._actions_for("search")
-        product = search.product_from_scan(barcode)
+    def _set_quantity__by_product(self, move_line, product, confirmation=False):
         handlers = self._set_quantity__scan_product_handlers()
-        if product:
-            response = self._use_handlers(handlers, move_line, product)
-            if response:
-                return response
+        return self._use_handlers(handlers, move_line, product)
 
-    def _set_quantity__scan_lot(self, move_line, barcode, confirmation=False):
-        search = self._actions_for("search")
-        lot = search.lot_from_scan(barcode)
+    def _set_quantity__by_lot(self, move_line, lot, confirmation=False):
         handlers = self._set_quantity__scan_product_handlers()
-        if lot:
-            product = lot.product_id
-            response = self._use_handlers(handlers, move_line, product, lot=lot)
-            if response:
-                return response
+        product = lot.product_id
+        return self._use_handlers(handlers, move_line, product, lot=lot)
 
-    def _set_quantity__scan_packaging(self, move_line, barcode, confirmation=False):
-        search = self._actions_for("search")
-        packaging = search.packaging_from_scan(barcode)
+    def _set_quantity__by_packaging(self, move_line, packaging, confirmation=False):
         handlers = self._set_quantity__scan_product_handlers()
-        if packaging:
-            product = packaging.product_id
-            response = self._use_handlers(
-                handlers, move_line, product, packaging=packaging
-            )
-            if response:
-                return response
+        product = packaging.product_id
+        return self._use_handlers(handlers, move_line, product, packaging=packaging)
 
     def _set_quantity__valid_dest_location_for_move_line_domain(self, move_line):
         move_line_dest_location = move_line.location_dest_id
         return [
             "|",
             ("id", "in", move_line_dest_location.ids),
             ("id", "child_of", move_line_dest_location.ids),
@@ -462,15 +535,15 @@
             ("id", "child_of", self.picking_types.default_location_dest_id.ids),
         ]
 
     def _valid_dest_location_for_menu(self):
         domain = self._valid_dest_location_for_menu_domain()
         return self.env["stock.location"].search(domain)
 
-    def _set_quantity__check_location(self, location, move_line, confirmation=False):
+    def _set_quantity__check_location(self, move_line, location, confirmation=False):
         valid_locations_for_move_line = (
             self._set_quantity__valid_dest_location_for_move_line(move_line)
         )
         valid_locations_for_menu = self._valid_dest_location_for_menu()
         message = False
         asking_confirmation = False
         if location in valid_locations_for_move_line:
@@ -506,183 +579,278 @@
         #   - 'location_content_transfer'
         #   - 'zone_picking'
         #   - 'cluster_picking' (but it is called '_unload_write_destination_on_lines')
         #
         # And all of them has a different implementation,
         # To refactor later.
         try:
-            # TODO loose dependency on 'shopfloor_checkout_sync' to avoid having
+            # TODO lose dependency on 'shopfloor_checkout_sync' to avoid having
             # yet another glue module. In the long term we should make
             # 'shopfloor_checkout_sync' use events and trash the overrides made
             # on all scenarios.
             checkout_sync = self._actions_for("checkout.sync")
         except NoComponentError:
             self._lock_lines(lines)
         else:
             self._lock_lines(checkout_sync._all_lines_to_lock(lines))
             checkout_sync._sync_checkout(lines, location)
         lines.location_dest_id = location
-        lines.package_level_id.location_dest_id = location
 
-    def _set_quantity__post_move(self, location, move_line, confirmation=False):
+    def _set_quantity__post_move(self, move_line, location, confirmation=False):
         # TODO qty_done = 0: transfer_no_qty_done
         # TODO qty done < product_qty: transfer_confirm_done
         self._write_destination_on_lines(move_line, location)
-        stock = self._actions_for("stock")
-        stock.validate_moves(move_line.move_id)
+        self._post_move(move_line)
         message = self.msg_store.transfer_done_success(move_line.picking_id)
         completion_info = self._actions_for("completion.info")
         completion_info_popup = completion_info.popup(move_line)
         return self._response_for_select_product(
-            move_line.location_id, message=message, popup=completion_info_popup
+            location=move_line.location_id,
+            package=move_line.package_id,
+            message=message,
+            popup=completion_info_popup,
         )
 
+    def _post_move(self, move_line):
+        # TODO: when we split the move, we still get a
+        # backorder, which should not be the case.
+        # See if there's a way to identify the moves
+        # generated through this mechanism and avoid creating them.
+        move_line._split_partial_quantity()
+        new_move = move_line.move_id.split_other_move_lines(
+            move_line, intersection=True
+        )
+        if new_move:
+            # A new move is created in case of partial quantity
+            new_move.extract_and_action_done()
+            return
+        # In case of full quantity, post the initial move
+        move_line.move_id.extract_and_action_done()
+
     def _find_user_move_line_domain(self, user):
         return [
             ("picking_id.user_id", "in", (False, self.env.uid)),
             ("picking_id.picking_type_id", "in", self.picking_types.ids),
             ("state", "in", ("assigned", "partially_available")),
             ("qty_done", ">", 0),
         ]
 
     def _find_user_move_line(self):
         """Return the first move line already started (if any)."""
         user = self.env.user
         domain = self._find_user_move_line_domain(user)
         return self.env["stock.move.line"].search(domain, limit=1)
 
-    def _set_quantity__by_product(self, move_line, barcode, confirmation=False):
-        product_handlers = [
-            self._set_quantity__scan_product,
-            self._set_quantity__scan_packaging,
-            self._set_quantity__scan_lot,
-        ]
-        product_response = self._use_handlers(product_handlers, move_line, barcode)
-        if product_response:
-            return product_response
-
-    def _set_quantity__by_location(self, move_line, barcode, confirmation=False):
-        search = self._actions_for("search")
-        location = search.location_from_scan(barcode)
-        handlers = [
-            # Cannot confirm if qty_done is not valid (> qty todo)
-            self._set_quantity__check_quantity_done,
+    def _set_quantity__by_location_handlers(self):
+        return [
             self._set_quantity__check_location,
             self._set_quantity__post_move,
         ]
-        if location:
+
+    def _set_quantity__by_location(self, move_line, location, confirmation=False):
+        # We're about to leave the `set_quantity` screen.
+        # First ensure that quantity is valid.
+        invalid_qty_response = self._set_quantity__check_quantity_done(move_line)
+        if invalid_qty_response:
+            return invalid_qty_response
+        move_line.result_package_id = False
+        handlers = self._set_quantity__by_location_handlers()
+        response = self._use_handlers(
+            handlers, move_line, location, confirmation=confirmation
+        )
+        if response:
+            return response
+
+    def _set_quantity__by_package(self, move_line, package, confirmation=False):
+        # We're about to leave the `set_quantity` screen.
+        # First ensure that quantity is valid.
+        invalid_qty_response = self._set_quantity__check_quantity_done(move_line)
+        if invalid_qty_response:
+            return invalid_qty_response
+        # If package isn't empty, then check its location then post the move
+        if package.quant_ids:
+            location = package.location_id
+            handlers = self._set_quantity__by_location_handlers()
             response = self._use_handlers(
-                handlers, location, move_line, confirmation=confirmation
+                handlers, move_line, location, confirmation=confirmation
             )
-            if response:
-                return response
+            move_line.result_package_id = package
+            return response
+        # Else, go to `set_location` screen
+        move_line.result_package_id = package
+        return self._response_for_set_location(move_line, package)
+
+    def _scan_location_or_package__by_package(self, package):
+        handlers = [
+            self._scan_package__check_location,
+            self._scan_package__check_stock,
+        ]
+        response = self._use_handlers(handlers, package)
+        if response:
+            return response
+        return self._response_for_select_product(
+            package=package, location=package.location_id
+        )
+
+    def _scan_location_or_package__by_location(self, location):
+        quants_in_location = self.env["stock.quant"].search(
+            [("location_id", "=", location.id), ("quantity", ">", 0)]
+        )
+        handlers = [
+            self._scan_location__location_found,
+            self._scan_location__check_location,
+            self._scan_location__check_stock,
+            self._scan_location__check_stock_packages,
+            self._scan_location__check_line_packages,
+        ]
+        response = self._use_handlers(handlers, location, quants_in_location)
+        if response:
+            return response
+        return self._response_for_select_product(location=location)
 
     # Endpoints
 
     def start(self):
         move_line = self._find_user_move_line()
         if move_line:
             message = self.msg_store.recovered_previous_session()
             return self._response_for_set_quantity(move_line, message=message)
-        return self._response_for_select_location()
+        return self._response_for_select_location_or_package()
 
-    def scan_location(self, barcode):
-        """Scan a source location.
+    def scan_location_or_package(self, barcode):
+        """Scan a source location or a source package.
 
         It is the starting point of this scenario.
 
-        If stock has been found in the scanned location, allows to scan a
-        product or a lot.
+        If stock has been found in the scanned location, or if a package has been found,
+        it allows to scan a product or a lot.
 
         Transitions:
         * select_product: to scan a product or a lot stored in the scanned location
         * start: no stock found or wrong barcode
         """
         search = self._actions_for("search")
-        location = search.location_from_scan(barcode)
-        handlers = [
-            self._scan_location__location_found,
-            self._scan_location__check_location,
-            self._scan_location__check_stock,
-        ]
-        response = self._use_handlers(handlers, location)
-        if response:
-            return response
-        return self._response_for_select_product(location)
+        handlers_by_type = {
+            "package": self._scan_location_or_package__by_package,
+            "location": self._scan_location_or_package__by_location,
+        }
+        search_result = search.find(barcode, types=handlers_by_type.keys())
+        handler = handlers_by_type.get(search_result.type)
+        if handler:
+            return handler(search_result.record)
+        message = self.msg_store.barcode_not_found()
+        return self._response_for_select_location_or_package(message=message)
 
     @with_savepoint
-    def scan_product(self, location_id, barcode):
-        """Looks for a move line in the given location, from a barcode.
+    def scan_product(self, barcode, location_id=None, package_id=None):
+        """Looks for a move line in the given location or package, from a barcode.
+
+        This endpoint will take either a location_id or a package_id,
+        depending on what the user has scanned in the previous screen.
+        This will be used as context to handle the scan and apply the necessary checks.
+
+        We will receive either:
+            - location_id
+            - package_id
 
         Barcode can be:
             - a product
             - a product packaging
             - a lot
         """
         location = self.env["stock.location"].browse(location_id)
-        if not location.exists():
-            return self._response_for_select_product(location)
-        handlers = [
-            self._scan_product__scan_product,
-            self._scan_product__scan_packaging,
-            self._scan_product__scan_lot,
-        ]
-        response = self._use_handlers(handlers, location, barcode)
-        if response:
-            return response
+        package = self.env["stock.quant.package"].browse(package_id)
+        if not location.exists() and not package.exists():
+            return self._response_for_select_location_or_package()
+        handlers_by_type = {
+            "product": self._scan_product__scan_product,
+            "packaging": self._scan_product__scan_packaging,
+            "lot": self._scan_product__scan_lot,
+        }
+        search = self._actions_for("search")
+        search_result = search.find(barcode, types=handlers_by_type.keys())
+        handler = handlers_by_type.get(search_result.type)
+        if handler:
+            return handler(search_result.record, location=location, package=package)
         message = self.msg_store.barcode_not_found()
-        return self._response_for_select_product(location, message=message)
+        return self._response_for_select_product(
+            location=location, package=package, message=message
+        )
 
     def scan_product__action_cancel(self):
-        return self._response_for_select_location()
+        return self._response_for_select_location_or_package()
 
     def set_quantity(self, selected_line_id, barcode, quantity, confirmation=False):
         """Sets quantity done if a product is scanned,
-        or posts the move if a location is scanned.
+        posts the move if a location is scanned
+        or moves the products to a package if a package is scanned.
         """
         move_line = self.env["stock.move.line"].browse(selected_line_id)
         if not move_line.exists():
             # TODO Should probably return to scan_product or scan_location?
             return self._response_for_set_quantity(move_line)
         self._set_quantity__set_picker_qty(move_line, quantity)
-        handlers = [
+        handlers_by_type = {
             # Increment qty done if a product / lot / packaging is scanned
-            self._set_quantity__by_product,
+            "product": self._set_quantity__by_product,
+            "lot": self._set_quantity__by_lot,
+            "packaging": self._set_quantity__by_packaging,
             # Post the move if a location is scanned
-            self._set_quantity__by_location,
-        ]
-        response = self._use_handlers(
-            handlers, move_line, barcode, confirmation=confirmation
-        )
-        if response:
-            return response
+            "location": self._set_quantity__by_location,
+            # Puts the product in a new or an existing pack
+            "package": self._set_quantity__by_package,
+        }
+        search = self._actions_for("search")
+        search_result = search.find(barcode, types=handlers_by_type.keys())
+        handler = handlers_by_type.get(search_result.type)
+        if handler:
+            return handler(move_line, search_result.record, confirmation=confirmation)
         message = self.msg_store.barcode_not_found()
         return self._response_for_set_quantity(move_line, message=message)
 
     def set_quantity__action_cancel(self, selected_line_id):
         stock = self._actions_for("stock")
         move_line = self.env["stock.move.line"].browse(selected_line_id).exists()
         stock.unmark_move_line_as_picked(move_line)
-        return self._response_for_select_location()
+        return self._response_for_select_location_or_package()
+
+    def set_location(self, selected_line_id, package_id, barcode):
+        """Sets the destination location
+        if a package is scanned using the set_quantity endpoint.
+        """
+        move_line = self.env["stock.move.line"].browse(selected_line_id)
+        handlers_by_type = {
+            # Post the move if a location is scanned
+            "location": self._set_quantity__by_location,
+        }
+        search = self._actions_for("search")
+        search_result = search.find(barcode, types=handlers_by_type.keys())
+        handler = handlers_by_type.get(search_result.type)
+        if handler:
+            return handler(move_line, search_result.record)
+        package = self.env["stock.quant.package"].browse(package_id)
+        message = self.msg_store.barcode_not_found()
+        return self._response_for_set_location(move_line, package, message=message)
 
 
 class ShopfloorSingleProductTransferValidator(Component):
     _inherit = "base.shopfloor.validator"
     _name = "shopfloor.single.product.transfer.validator"
     _usage = "single_product_transfer.validator"
 
     def start(self):
         return {}
 
-    def scan_location(self):
+    def scan_location_or_package(self):
         return {"barcode": {"required": True, "type": "string"}}
 
     def scan_product(self):
         return {
-            "location_id": {"coerce": to_int, "required": True, "type": "integer"},
+            "location_id": {"coerce": to_int, "required": False, "type": "integer"},
+            "package_id": {"coerce": to_int, "required": False, "type": "integer"},
             "barcode": {"required": True, "type": "string"},
         }
 
     def scan_product__action_cancel(self):
         return {}
 
     def set_quantity(self):
@@ -694,33 +862,41 @@
         }
 
     def set_quantity__action_cancel(self):
         return {
             "selected_line_id": {"coerce": to_int, "required": True, "type": "integer"},
         }
 
+    def set_location(self):
+        return {
+            "selected_line_id": {"coerce": to_int, "required": True, "type": "integer"},
+            "package_id": {"coerce": to_int, "required": True, "type": "integer"},
+            "barcode": {"required": True, "type": "string"},
+        }
+
 
 class ShopfloorSingleProductTransferValidatorResponse(Component):
     _inherit = "base.shopfloor.validator.response"
     _name = "shopfloor.single.product.transfer.validator.response"
     _usage = "single_product_transfer.validator.response"
 
-    _start_state = "select_location"
+    _start_state = "select_location_or_package"
 
     def _states(self):
         return {
-            "select_location": self._schema_select_location,
+            "select_location_or_package": self._schema_select_location_or_package,
             "select_product": self._schema_select_product,
             "set_quantity": self._schema_set_quantity,
+            "set_location": self._schema_set_location,
         }
 
     def start(self):
         return self._response_schema(next_states=self._start_next_states())
 
-    def scan_location(self):
+    def scan_location_or_package(self):
         return self._response_schema(next_states=self._scan_location_next_states())
 
     def scan_product(self):
         return self._response_schema(next_states=self._scan_product_next_states())
 
     def scan_product__action_cancel(self):
         return self._response_schema(
@@ -731,39 +907,63 @@
         return self._response_schema(next_states=self._set_quantity_next_states())
 
     def set_quantity__action_cancel(self):
         return self._response_schema(
             next_states=self._set_quantity__action_cancel_next_states()
         )
 
+    def set_location(self):
+        return self._response_schema(next_states=self._set_location_next_states())
+
     def _start_next_states(self):
-        return {"select_location", "set_quantity"}
+        return {"select_location_or_package", "set_quantity"}
 
     def _scan_location_next_states(self):
-        return {"select_location", "select_product"}
+        return {"select_location_or_package", "select_product"}
 
     def _scan_product_next_states(self):
         return {"select_product", "set_quantity"}
 
     def _scan_product__action_cancel_next_states(self):
-        return {"select_location"}
+        return {"select_location_or_package"}
 
     def _set_quantity_next_states(self):
-        return {"set_quantity", "select_product"}
+        return {"set_quantity", "select_product", "set_location"}
 
     def _set_quantity__action_cancel_next_states(self):
-        return {"select_location"}
+        return {"select_location_or_package"}
+
+    def _set_location_next_states(self):
+        return {"set_quantity", "select_product", "set_location"}
 
     @property
-    def _schema_select_location(self):
+    def _schema_select_location_or_package(self):
         return {}
 
     @property
     def _schema_select_product(self):
-        return {"location": {"type": "dict", "schema": self.schemas.location()}}
+        return {
+            "location": {
+                "type": "dict",
+                "required": False,
+                "schema": self.schemas.location(),
+            },
+            "package": {
+                "type": "dict",
+                "required": False,
+                "schema": self.schemas.package(),
+            },
+        }
 
     @property
     def _schema_set_quantity(self):
         return {
             "move_line": {"type": "dict", "schema": self.schemas.move_line()},
             "asking_confirmation": {"type": "boolean", "nullable": True},
         }
+
+    @property
+    def _schema_set_location(self):
+        return {
+            "move_line": {"type": "dict", "schema": self.schemas.move_line()},
+            "package": {"type": "dict", "schema": self.schemas.package()},
+        }
```

## odoo/addons/shopfloor_single_product_transfer/tests/__init__.py

```diff
@@ -1,5 +1,6 @@
 from . import test_start
-from . import test_scan_location
+from . import test_scan_location_or_package
 from . import test_scan_product
 from . import test_set_quantity
 from . import test_set_quantity_checkout_sync
+from . import test_set_location
```

## odoo/addons/shopfloor_single_product_transfer/tests/common.py

```diff
@@ -114,14 +114,17 @@
 
     def _data_for_location(self, location):
         return self.data.location(location)
 
     def _data_for_move_line(self, move_line):
         return self.data.move_line(move_line)
 
+    def _data_for_package(self, package):
+        return self.data.package(package)
+
     @classmethod
     def get_new_move_line(cls):
         return cls.env["stock.move.line"].search(
             [("id", "not in", cls.existing_move_line_ids)]
         )
 
     @classmethod
```

## odoo/addons/shopfloor_single_product_transfer/tests/test_scan_product.py

```diff
@@ -488,15 +488,15 @@
         )
         move_line = self.get_new_move_line()
         self.assertEqual(move_line.qty_done, 1)
         self.assertEqual(move_line.product_uom_qty, max_qty_done)
 
     def test_action_cancel(self):
         response = self.service.dispatch("scan_product__action_cancel")
-        self.assert_response(response, next_state="select_location", data={})
+        self.assert_response(response, next_state="select_location_or_package", data={})
 
     def test_scan_product_packaging(self):
         location = self.location_src
         packaging = self.product_a_packaging
         product = packaging.product_id
         self._add_stock_to_product(product, location, 10)
         picking = self._create_picking(lines=[(product, 10)])
```

## odoo/addons/shopfloor_single_product_transfer/tests/test_set_quantity.py

```diff
@@ -549,15 +549,17 @@
         move_line.qty_done = 10.0
         # Result here already tested in
         # `test_scan_product::TestScanProduct::test_scan_product_with_move_line`
         response = self.service.dispatch(
             "set_quantity__action_cancel", params={"selected_line_id": move_line.id}
         )
         data = {}
-        self.assert_response(response, next_state="select_location", data=data)
+        self.assert_response(
+            response, next_state="select_location_or_package", data=data
+        )
         # Ensure the qty_done and user has been reset.
         self.assertFalse(move_line.picking_id.user_id)
         self.assertEqual(move_line.qty_done, 0.0)
 
     def test_set_quantity_done_with_completion_info(self):
         self.picking_type.sudo().display_completion_info = "next_picking_ready"
         picking = self._setup_picking()
@@ -584,7 +586,73 @@
         self.assert_response(
             response,
             next_state="select_product",
             message=expected_message,
             data=data,
             popup=expected_popup,
         )
+
+    def test_set_quantity_scan_package_not_empty(self):
+        # We scan a package that's not empty
+        # and its location is selected.
+        package = (
+            self.env["stock.quant.package"].sudo().create({"name": "test-package"})
+        )
+        self.env["stock.quant"].sudo().create(
+            {
+                "package_id": package.id,
+                "location_id": self.dispatch_location.id,
+                "product_id": self.product.id,
+                "quantity": 10.0,
+            }
+        )
+        picking = self._setup_picking()
+        move_line = picking.move_line_ids
+        response = self.service.dispatch(
+            "set_quantity",
+            params={
+                "selected_line_id": move_line.id,
+                "quantity": 10.0,
+                "barcode": package.name,
+            },
+        )
+        expected_data = {
+            "location": self._data_for_location(self.location),
+        }
+        expected_message = self.msg_store.transfer_done_success(move_line.picking_id)
+        completion_info = self.service._actions_for("completion.info")
+        expected_popup = completion_info.popup(move_line)
+        self.assert_response(
+            response,
+            next_state="select_product",
+            data=expected_data,
+            message=expected_message,
+            popup=expected_popup,
+        )
+        self.assertEqual(package, move_line.result_package_id)
+
+    def test_set_quantity_scan_package_empty(self):
+        # We scan an empty package
+        # and are redirected to set_location.
+        package = (
+            self.env["stock.quant.package"].sudo().create({"name": "test-package"})
+        )
+        picking = self._setup_picking()
+        move_line = picking.move_line_ids
+        response = self.service.dispatch(
+            "set_quantity",
+            params={
+                "selected_line_id": move_line.id,
+                "quantity": 10.0,
+                "barcode": package.name,
+            },
+        )
+        expected_data = {
+            "move_line": self._data_for_move_line(move_line),
+            "package": self._data_for_package(package),
+        }
+        self.assert_response(
+            response,
+            next_state="set_location",
+            data=expected_data,
+        )
+        self.assertEqual(package, move_line.result_package_id)
```

## odoo/addons/shopfloor_single_product_transfer/tests/test_start.py

```diff
@@ -3,15 +3,15 @@
 
 from .common import CommonCase
 
 
 class TestStart(CommonCase):
     def test_start(self):
         response = self.service.dispatch("start")
-        self.assert_response(response, next_state="select_location", data={})
+        self.assert_response(response, next_state="select_location_or_package", data={})
 
     def test_recover(self):
         product = self.product_a
         location = self.location_src
         self._add_stock_to_product(product, location, 10)
         picking = self._create_picking(lines=[(product, 10)])
         picking.user_id = self.env.user
```

## Comparing `odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.0.dist-info/METADATA` & `odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.1.dev5.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: odoo14-addon-shopfloor-single-product-transfer
-Version: 14.0.1.1.0
+Version: 14.0.1.1.1.dev5
 Summary: Move an item from one location to another.
 Home-page: https://github.com/OCA/wms
 Author: Camptocamp, Odoo Community Association (OCA)
 Author-email: support@odoo-community.org
 License: AGPL-3
 Platform: UNKNOWN
 Classifier: Programming Language :: Python
```

## Comparing `odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.0.dist-info/RECORD` & `odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.1.dev5.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -10,21 +10,22 @@
 odoo/addons/shopfloor_single_product_transfer/docs/oca_logo.png,sha256=tuADeCURe0ZTpQn-bnsepQdCrUJi4yrNhkQ1eXd4eO4,3297
 odoo/addons/shopfloor_single_product_transfer/i18n/shopfloor_single_product_transfer.pot,sha256=8LTw986G3VsRKx3_9yg7hInQu9N_dMr8PE46XT4k1Nc,784
 odoo/addons/shopfloor_single_product_transfer/migrations/14.0.1.1.0/post-migrate.py,sha256=qeUTbvKcvTdw_wsKjO-8hbQoPxCppDEewXFaO_H6n4c,438
 odoo/addons/shopfloor_single_product_transfer/readme/CONTRIBUTORS.rst,sha256=kHrpulo4pulRuabz9hVs2xC4nyC9WECwLhgbe2RmEcs,58
 odoo/addons/shopfloor_single_product_transfer/readme/DESCRIPTION.rst,sha256=pUvSSYXS650Wn36v-hXrdh6IA5k4HR3xSoaOwG_Qxgw,63
 odoo/addons/shopfloor_single_product_transfer/readme/USAGE.rst,sha256=1FEtCScCRDBTUzc4m5tsbccLVwad-yLTu5dAq4C9TyQ,1274
 odoo/addons/shopfloor_single_product_transfer/services/__init__.py,sha256=iPe9aZxvLu_PZXrFPBc86kTykEFc9J0JrAY6zjHvlFo,38
-odoo/addons/shopfloor_single_product_transfer/services/single_product_transfer.py,sha256=ho9OrF-vJeE9jApG86S4MU3rZBiRcNONRk4JevpqqPc,31235
+odoo/addons/shopfloor_single_product_transfer/services/single_product_transfer.py,sha256=N1Ou-STu8bDr67wwQR0uL-YMKrxyIKbylhsovrhTwVo,40376
 odoo/addons/shopfloor_single_product_transfer/static/description/icon.png,sha256=6xBPJauaFOF0KDHfHgQopSc28kKvxMaeoQFQWZtfZDo,9455
 odoo/addons/shopfloor_single_product_transfer/static/description/index.html,sha256=HMunzrsGZAhyRiDR3wgHJVXtKZydMCFbkp7uW3gOrHc,13699
-odoo/addons/shopfloor_single_product_transfer/tests/__init__.py,sha256=EnsZK587Jz3RD876JWW-MF2PAvQIUz7XaeGv2NsZ9OY,168
-odoo/addons/shopfloor_single_product_transfer/tests/common.py,sha256=oya4gnU4o7TcNtGY71ibk7cFI4K4FPrP2QredcywyZE,4433
-odoo/addons/shopfloor_single_product_transfer/tests/test_scan_location.py,sha256=F1gyEMxTsCUdvn9bTqzoTwaYiQPJ8iTa4MhnYOcGnq0,1863
-odoo/addons/shopfloor_single_product_transfer/tests/test_scan_product.py,sha256=A9iAw-AU7AS9s9NjpD42fshIBFnp5T5b_3sJQuE4468,22837
-odoo/addons/shopfloor_single_product_transfer/tests/test_set_quantity.py,sha256=e3x0VdIlrUPr_XYY4WEIU6k3FvfvOVhtyoNdHxswowI,23165
+odoo/addons/shopfloor_single_product_transfer/tests/__init__.py,sha256=fL4UbuM-U1PvNXYSgRIv-jawCupgkTRhPFfZKv7pYvk,211
+odoo/addons/shopfloor_single_product_transfer/tests/common.py,sha256=eZuVV4Rw6JV5ZKwf3I2gX7uWmglwUdNY3hbivTRqvhI,4518
+odoo/addons/shopfloor_single_product_transfer/tests/test_scan_location_or_package.py,sha256=jMyFpJA26njvVMd9gY5Lm5HBP__SsRySsyFA8thRv8w,4072
+odoo/addons/shopfloor_single_product_transfer/tests/test_scan_product.py,sha256=9LMfXH1y_psVn5AgJtmzles9_hO0fmJOZFqZzIK5Xl8,22848
+odoo/addons/shopfloor_single_product_transfer/tests/test_set_location.py,sha256=Wk0OTnliXLgfGaWUMIPsivfJXq8Qh8SUdNPZdsCk--A,2569
+odoo/addons/shopfloor_single_product_transfer/tests/test_set_quantity.py,sha256=C-hpW-yEiPEJUwGk8UkVG7_ZseYpo1W-tR2aI8JfGAU,25549
 odoo/addons/shopfloor_single_product_transfer/tests/test_set_quantity_checkout_sync.py,sha256=QVMZsFRg8-d0HOmVI5eLyIxUu81pZrrdVuf3h9WrD1Q,3712
-odoo/addons/shopfloor_single_product_transfer/tests/test_start.py,sha256=AGM9RZ7uAxu0x3ZgMin1WpsvDh407XHPKoI2DmTYUf8,1081
-odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.0.dist-info/METADATA,sha256=VgtXi9XjhHXGh9gh0Rssc5WH9onYsyEdsXL8cUZ0csU,4827
-odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.0.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.0.dist-info/top_level.txt,sha256=qBj40grFkGOfDZ2WDSw3y1RnDlgG0u8rP8pvGNdbz4w,5
-odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.0.dist-info/RECORD,,
+odoo/addons/shopfloor_single_product_transfer/tests/test_start.py,sha256=yH08mfBDDdHPy46cDBhJ4i_-cLqe6IQlf2QtqHqMLec,1092
+odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.1.dev5.dist-info/METADATA,sha256=5_1GKFV-G1YneAnlvqnMKetRg30bj5IrwWAZceoEyGw,4832
+odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.1.dev5.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.1.dev5.dist-info/top_level.txt,sha256=qBj40grFkGOfDZ2WDSw3y1RnDlgG0u8rP8pvGNdbz4w,5
+odoo14_addon_shopfloor_single_product_transfer-14.0.1.1.1.dev5.dist-info/RECORD,,
```

