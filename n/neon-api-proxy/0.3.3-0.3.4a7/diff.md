# Comparing `tmp/neon_api_proxy-0.3.3-py3-none-any.whl.zip` & `tmp/neon_api_proxy-0.3.4a7-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,30 +1,30 @@
-Zip file size: 40172 bytes, number of entries: 28
--rw-r--r--  2.0 unx     1831 b- defN 22-Jul-20 20:42 neon_api_proxy/__init__.py
--rw-r--r--  2.0 unx     3447 b- defN 22-Jul-20 20:42 neon_api_proxy/__main__.py
--rw-r--r--  2.0 unx     2031 b- defN 22-Jul-20 20:42 neon_api_proxy/alpha_vantage_api.py
--rw-r--r--  2.0 unx     6131 b- defN 22-Jul-20 20:42 neon_api_proxy/api_connector.py
--rw-r--r--  2.0 unx     3484 b- defN 22-Jul-20 20:42 neon_api_proxy/cached_api.py
--rw-r--r--  2.0 unx     2663 b- defN 22-Jul-20 20:42 neon_api_proxy/config.py
--rw-r--r--  2.0 unx     4487 b- defN 22-Jul-20 20:42 neon_api_proxy/controller.py
--rw-r--r--  2.0 unx     2021 b- defN 22-Jul-20 20:42 neon_api_proxy/owm_api.py
--rw-r--r--  2.0 unx     2631 b- defN 22-Jul-20 20:42 neon_api_proxy/socket_handler.py
--rw-r--r--  2.0 unx     2022 b- defN 22-Jul-20 20:42 neon_api_proxy/test_api.py
--rw-r--r--  2.0 unx     2025 b- defN 22-Jul-20 20:42 neon_api_proxy/wolfram_api.py
--rw-r--r--  2.0 unx     4825 b- defN 22-Jul-20 20:42 neon_api_proxy/client/__init__.py
--rw-r--r--  2.0 unx     4546 b- defN 22-Jul-20 20:42 neon_api_proxy/client/alpha_vantage.py
--rw-r--r--  2.0 unx     3495 b- defN 22-Jul-20 20:42 neon_api_proxy/client/financial_modeling_prep.py
--rw-r--r--  2.0 unx     4813 b- defN 22-Jul-20 20:42 neon_api_proxy/client/open_weather_map.py
--rw-r--r--  2.0 unx     4970 b- defN 22-Jul-20 20:42 neon_api_proxy/client/wolfram_alpha.py
--rw-r--r--  2.0 unx     1831 b- defN 22-Jul-20 20:42 neon_api_proxy/services/__init__.py
--rw-r--r--  2.0 unx     5373 b- defN 22-Jul-20 20:42 neon_api_proxy/services/alpha_vantage_api.py
--rw-r--r--  2.0 unx     4235 b- defN 22-Jul-20 20:42 neon_api_proxy/services/owm_api.py
--rw-r--r--  2.0 unx     2510 b- defN 22-Jul-20 20:42 neon_api_proxy/services/test_api.py
--rw-r--r--  2.0 unx     7109 b- defN 22-Jul-20 20:42 neon_api_proxy/services/wolfram_api.py
--rw-r--r--  2.0 unx     1635 b- defN 22-Jul-20 20:42 neon_api_proxy-0.3.3.dist-info/LICENSE.md
--rw-r--r--  2.0 unx      522 b- defN 22-Jul-20 20:42 neon_api_proxy-0.3.3.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Jul-20 20:42 neon_api_proxy-0.3.3.dist-info/WHEEL
--rw-r--r--  2.0 unx       65 b- defN 22-Jul-20 20:42 neon_api_proxy-0.3.3.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       15 b- defN 22-Jul-20 20:42 neon_api_proxy-0.3.3.dist-info/top_level.txt
--rw-r--r--  2.0 unx        1 b- defN 22-Jul-20 20:42 neon_api_proxy-0.3.3.dist-info/zip-safe
-?rw-rw-r--  2.0 unx     2509 b- defN 22-Jul-20 20:42 neon_api_proxy-0.3.3.dist-info/RECORD
-28 files, 81319 bytes uncompressed, 36068 bytes compressed:  55.6%
+Zip file size: 41075 bytes, number of entries: 28
+-rw-r--r--  2.0 unx     1831 b- defN 23-Jun-15 03:13 neon_api_proxy/__init__.py
+-rw-r--r--  2.0 unx     2504 b- defN 23-Jun-15 03:13 neon_api_proxy/__main__.py
+-rw-r--r--  2.0 unx     2028 b- defN 23-Jun-15 03:13 neon_api_proxy/alpha_vantage_api.py
+-rw-r--r--  2.0 unx     6322 b- defN 23-Jun-15 03:13 neon_api_proxy/api_connector.py
+-rw-r--r--  2.0 unx     3602 b- defN 23-Jun-15 03:13 neon_api_proxy/cached_api.py
+-rw-r--r--  2.0 unx     2714 b- defN 23-Jun-15 03:13 neon_api_proxy/config.py
+-rw-r--r--  2.0 unx     5274 b- defN 23-Jun-15 03:13 neon_api_proxy/controller.py
+-rw-r--r--  2.0 unx     2018 b- defN 23-Jun-15 03:13 neon_api_proxy/owm_api.py
+-rw-r--r--  2.0 unx     2672 b- defN 23-Jun-15 03:13 neon_api_proxy/socket_handler.py
+-rw-r--r--  2.0 unx     2019 b- defN 23-Jun-15 03:13 neon_api_proxy/test_api.py
+-rw-r--r--  2.0 unx     2022 b- defN 23-Jun-15 03:13 neon_api_proxy/wolfram_api.py
+-rw-r--r--  2.0 unx     4935 b- defN 23-Jun-15 03:13 neon_api_proxy/client/__init__.py
+-rw-r--r--  2.0 unx     4564 b- defN 23-Jun-15 03:13 neon_api_proxy/client/alpha_vantage.py
+-rw-r--r--  2.0 unx     3435 b- defN 23-Jun-15 03:13 neon_api_proxy/client/financial_modeling_prep.py
+-rw-r--r--  2.0 unx     4795 b- defN 23-Jun-15 03:13 neon_api_proxy/client/open_weather_map.py
+-rw-r--r--  2.0 unx     5074 b- defN 23-Jun-15 03:13 neon_api_proxy/client/wolfram_alpha.py
+-rw-r--r--  2.0 unx     1831 b- defN 23-Jun-15 03:13 neon_api_proxy/services/__init__.py
+-rw-r--r--  2.0 unx     5340 b- defN 23-Jun-15 03:13 neon_api_proxy/services/alpha_vantage_api.py
+-rw-r--r--  2.0 unx     4244 b- defN 23-Jun-15 03:13 neon_api_proxy/services/owm_api.py
+-rw-r--r--  2.0 unx     2323 b- defN 23-Jun-15 03:13 neon_api_proxy/services/test_api.py
+-rw-r--r--  2.0 unx     7166 b- defN 23-Jun-15 03:13 neon_api_proxy/services/wolfram_api.py
+-rw-r--r--  2.0 unx     1635 b- defN 23-Jun-15 03:13 neon_api_proxy-0.3.4a7.dist-info/LICENSE.md
+-rw-r--r--  2.0 unx     2438 b- defN 23-Jun-15 03:13 neon_api_proxy-0.3.4a7.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-15 03:13 neon_api_proxy-0.3.4a7.dist-info/WHEEL
+-rw-r--r--  2.0 unx       64 b- defN 23-Jun-15 03:13 neon_api_proxy-0.3.4a7.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       15 b- defN 23-Jun-15 03:13 neon_api_proxy-0.3.4a7.dist-info/top_level.txt
+-rw-r--r--  2.0 unx        1 b- defN 23-Jun-15 03:13 neon_api_proxy-0.3.4a7.dist-info/zip-safe
+-rw-rw-r--  2.0 unx     2524 b- defN 23-Jun-15 03:13 neon_api_proxy-0.3.4a7.dist-info/RECORD
+28 files, 83482 bytes uncompressed, 36943 bytes compressed:  55.7%
```

## zipnote {}

```diff
@@ -57,29 +57,29 @@
 
 Filename: neon_api_proxy/services/test_api.py
 Comment: 
 
 Filename: neon_api_proxy/services/wolfram_api.py
 Comment: 
 
-Filename: neon_api_proxy-0.3.3.dist-info/LICENSE.md
+Filename: neon_api_proxy-0.3.4a7.dist-info/LICENSE.md
 Comment: 
 
-Filename: neon_api_proxy-0.3.3.dist-info/METADATA
+Filename: neon_api_proxy-0.3.4a7.dist-info/METADATA
 Comment: 
 
-Filename: neon_api_proxy-0.3.3.dist-info/WHEEL
+Filename: neon_api_proxy-0.3.4a7.dist-info/WHEEL
 Comment: 
 
-Filename: neon_api_proxy-0.3.3.dist-info/entry_points.txt
+Filename: neon_api_proxy-0.3.4a7.dist-info/entry_points.txt
 Comment: 
 
-Filename: neon_api_proxy-0.3.3.dist-info/top_level.txt
+Filename: neon_api_proxy-0.3.4a7.dist-info/top_level.txt
 Comment: 
 
-Filename: neon_api_proxy-0.3.3.dist-info/zip-safe
+Filename: neon_api_proxy-0.3.4a7.dist-info/zip-safe
 Comment: 
 
-Filename: neon_api_proxy-0.3.3.dist-info/RECORD
+Filename: neon_api_proxy-0.3.4a7.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## neon_api_proxy/__main__.py

```diff
@@ -22,56 +22,31 @@
 # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-import argparse
-import socketserver
-
 from ovos_utils import wait_for_exit_signal
+from ovos_utils.log import init_service_logger
 
 from neon_api_proxy.api_connector import NeonAPIMQConnector
-from neon_api_proxy.config import get_proxy_config
 from neon_api_proxy.controller import NeonAPIProxyController
-from neon_api_proxy.socket_handler import NeonAPITCPHandler
-
-
-def run_tcp_handler(config_data: dict = None):
-    """
-        Runs threaded TCP socket on specified address and port
-        @param config_data: dict with configuration data for the ProxyController
-    """
-    parser = argparse.ArgumentParser(description='Parameters for TCP socket server')
 
-    parser.add_argument('--host',
-                        type=str,
-                        default='127.0.0.1',
-                        help='Socket host (defaults to 127.0.0.1)')
-    parser.add_argument('--port',
-                        type=int,
-                        default=8555,
-                        help='Socket port (defaults to 8555)')
-    args = parser.parse_args()
-
-    host, port = args.host, args.port
-
-    with socketserver.ThreadingTCPServer((host, port), NeonAPITCPHandler) as server:
-        server.controller = NeonAPIProxyController(config=config_data)
-        server.serve_forever()
+init_service_logger("neon-api-proxy")
 
 
 def run_mq_handler():
     """
     Start the ProxyController and MQConnector services
     """
-    config_data = get_proxy_config()
-    proxy = NeonAPIProxyController(config_data)
-    connector = NeonAPIMQConnector(config=None, service_name='neon_api_connector', proxy=proxy)
+    proxy = NeonAPIProxyController()
+    connector = NeonAPIMQConnector(config=None,
+                                   service_name='neon_api_connector',
+                                   proxy=proxy)
     connector.run()
     wait_for_exit_signal()
 
 
 def main():
     run_mq_handler()
```

## neon_api_proxy/alpha_vantage_api.py

```diff
@@ -23,10 +23,10 @@
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 from neon_api_proxy.services.alpha_vantage_api import *
-from neon_utils.logger import LOG
+from ovos_utils.log import LOG
 LOG.warning("This reference is deprecated, import from neon_api_proxy.services")
 # TODO: Deprecate in v1.0.0
```

## neon_api_proxy/api_connector.py

```diff
@@ -25,25 +25,26 @@
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 import pika.channel
 
 from typing import Optional
-from neon_utils import LOG
-from neon_utils.socket_utils import b64_to_dict, dict_to_b64
+from ovos_utils.log import LOG
+from neon_mq_connector.utils.network_utils import b64_to_dict, dict_to_b64
 from neon_mq_connector.connector import MQConnector
 
 from neon_api_proxy.controller import NeonAPIProxyController
 
 
 class NeonAPIMQConnector(MQConnector):
     """Adapter for establishing connection between Neon API and MQ broker"""
 
-    def __init__(self, config: Optional[dict], service_name: str, proxy: NeonAPIProxyController):
+    def __init__(self, config: Optional[dict], service_name: str,
+                 proxy: NeonAPIProxyController):
         """
             Additionally accepts message bus connection properties
 
             :param config: dictionary containing MQ configuration data
             :param service_name: name of the service instance
         """
         super().__init__(config, service_name)
@@ -66,39 +67,44 @@
         """
         message_id = None
         try:
             if body and isinstance(body, bytes):
                 request = b64_to_dict(body)
                 tokens = self.extract_agent_tokens(request)
 
-                message_id = tokens.pop('message_id', request.get("message_id", None))
-                LOG.info(f"request={request}; message_id={message_id}")
+                message_id = tokens.pop('message_id', request.get("message_id",
+                                                                  None))
+                LOG.info(f"request={request}")
 
                 respond = self.proxy.resolve_query(request)
-                LOG.info(f"message={message_id} status={respond.get('status_code')}")
+                LOG.info(f"message={message_id} "
+                         f"status={respond.get('status_code')}")
 
                 try:
-                    respond['content'] = bytes(respond.get('content', b'')).decode(encoding='utf-8')
+                    respond['content'] = bytes(respond.get('content', b'')).\
+                        decode(encoding='utf-8')
                 except Exception as e:
                     LOG.error(e)
                 respond = {**respond, **tokens}
                 LOG.debug(f"respond={respond}")
                 data = dict_to_b64(respond)
 
                 routing_key = request.get('routing_key', 'neon_api_output')
                 # queue declare is idempotent, just making sure queue exists
                 channel.queue_declare(queue=routing_key)
-                channel.basic_publish(exchange='',
-                                      routing_key=routing_key,
-                                      body=data,
-                                      properties=pika.BasicProperties(expiration='1000')
-                                      )
+                channel.basic_publish(
+                    exchange='',
+                    routing_key=routing_key,
+                    body=data,
+                    properties=pika.BasicProperties(expiration='1000')
+                )
                 channel.basic_ack(method.delivery_tag)
             else:
-                raise TypeError(f'Invalid body received, expected: bytes string; got: {type(body)}')
+                raise TypeError(f'Invalid body received, expected bytes string;'
+                                f' got: {type(body)}')
         except Exception as e:
             LOG.error(f"message_id={message_id}")
             LOG.error(e)
 
     @staticmethod
     def extract_agent_tokens(msg_data: dict) -> dict:
         """
@@ -108,24 +114,27 @@
             :return: dictionary containing tokens dedicated to resolved agent
         """
         tokens = dict()
         request_agent = msg_data.pop('agent', 'undefined')
         if 'klatchat' in request_agent:
             LOG.info('Resolved agent is "klatchat"')
             tokens['cid'] = msg_data.pop("cid", None)
-            tokens['message_id'] = tokens['replied_message'] = msg_data.get('messageID', None)
+            tokens['message_id'] = tokens['replied_message'] = \
+                msg_data.get('messageID', None)
         else:
             LOG.warning('Failed to resolve an agent from the message data')
         return tokens
 
     def handle_error(self, thread, exception):
         LOG.error(f"{exception} occurred in {thread}")
         LOG.info(f"Restarting Consumers")
         self.stop()
         self.run()
 
     def pre_run(self, **kwargs):
-        self.register_consumer("neon_api_consumer", self.vhost, 'neon_api_input', self.handle_api_input, auto_ack=False)
+        self.register_consumer("neon_api_consumer", self.vhost,
+                               'neon_api_input', self.handle_api_input,
+                               auto_ack=False)
         self.register_consumer("neon_api_consumer_targeted",
                                self.vhost,
                                f'neon_api_input_{self.service_id}',
                                self.handle_api_input, auto_ack=False)
```

## neon_api_proxy/cached_api.py

```diff
@@ -32,28 +32,32 @@
 from requests import Response
 from requests.adapters import HTTPAdapter
 
 
 class CachedAPI:
     def __init__(self, cache_name):
         # TODO: Setup a database for this
-        self.session = CachedSession(backend='memory', cache_name=cache_name, expire_after=-1)
+        self.session = CachedSession(backend='memory', cache_name=cache_name,
+                                     expire_after=-1)
         self.session.mount('http://', HTTPAdapter(max_retries=3))
         self.session.mount('https://', HTTPAdapter(max_retries=3))
 
-    def get_with_cache_timeout(self, url: str, timeout: ExpirationTime = -1) -> Union[Response, CachedResponse]:
+    def get_with_cache_timeout(self, url: str,
+                               timeout: ExpirationTime = -1) -> \
+            Union[Response, CachedResponse]:
         """
         Make a request with a specified time to cache the response
         :param url: URL to request
         :param timeout: Time to remain cached
         :return: Response or CachedResponse
         """
         if timeout == 0:
             return self.get_bypass_cache(url)
-        return self.session.request("get", url, expire_after=timeout, timeout=10)
+        return self.session.request("get", url, expire_after=timeout,
+                                    timeout=10)
         # with self.session.request_expire_after(timeout):
         #     return self.session.get(url)
 
     def get_bypass_cache(self, url: str) -> Response:
         """
         Make a request without using any cached responses
         :param url: URL to request
```

## neon_api_proxy/config.py

```diff
@@ -25,16 +25,15 @@
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 import json
 
 from os import environ, path
-
-# TODO: Consider moving this to neon_utils package
+from ovos_utils.log import LOG
 
 
 def get_proxy_config() -> dict:
     """
     Locates a valid configuration file for proxy service credentials
     :return: dict containing "SERVICES" key with proxy service configurations
     """
@@ -43,13 +42,14 @@
         path.expanduser("~/.config/neon/credentials.json"),
         path.expanduser("~/.local/share/neon/credentials.json")
     ]
     valid_config_path = None
     for p in valid_config_paths:
         if p and path.isfile(p):
             valid_config_path = p
+            LOG.warning(f"Deprecated configuration file found at: {p}")
             break
     if not valid_config_path:
         return dict()
     with open(valid_config_path) as input_file:
         proxy_service_config = json.load(input_file)
     return proxy_service_config
```

## neon_api_proxy/controller.py

```diff
@@ -22,70 +22,93 @@
 # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-from neon_utils.configuration_utils import get_neon_auth_config, LOG
-
+from os.path import join, isfile
+from ovos_utils.log import LOG
+from ovos_config.config import Configuration
+from neon_utils.configuration_utils import NGIConfig, init_config_dir, \
+    get_config_dir
 from neon_api_proxy.services.owm_api import OpenWeatherAPI
 from neon_api_proxy.services.alpha_vantage_api import AlphaVantageAPI
 from neon_api_proxy.services.wolfram_api import WolframAPI
 from neon_api_proxy.services.test_api import TestAPI
 
 
 class NeonAPIProxyController:
     """
-        Generic module for binding between service name and actual service for fulfilling request
+    Resolves a service name to an instance to provide external API access
     """
 
     # Mapping between string service name and actual class
     service_class_mapping = {
         'wolfram_alpha': WolframAPI,
         'alpha_vantage': AlphaVantageAPI,
         'open_weather_map': OpenWeatherAPI,
         'api_test_endpoint': TestAPI
     }
 
     def __init__(self, config: dict = None):
         """
             @param config: configurations dictionary
         """
-        self.config = config or get_neon_auth_config()["api_services"]
-        self.service_instance_mapping = self.init_service_instances(self.service_class_mapping)
+        self.config = config or self._init_config()
+        self.service_instance_mapping = self.init_service_instances(
+            self.service_class_mapping)
+
+    @staticmethod
+    def _init_config() -> dict:
+        from neon_api_proxy.config import get_proxy_config
+        legacy_config = get_proxy_config()
+        if legacy_config:
+            return legacy_config
+        legacy_config_file = join(get_config_dir(), "ngi_auth_vars.yml")
+        if isfile(legacy_config_file):
+            LOG.warning(f"Legacy configuration found at: {legacy_config_file}")
+            return NGIConfig("ngi_auth_vars").get("api_services", {})
+        else:
+            return Configuration().get("keys", {}).get("api_services", {})
 
     def init_service_instances(self, service_class_mapping: dict) -> dict:
         """
-            Maps service classes to their instances
-            @param service_class_mapping: dictionary containing mapping between service string name
-                    and python class representing it
+        Maps service classes to their instances
+        @param service_class_mapping: dictionary containing mapping between
+            service string name and python class representing it
 
-            @return dictionary containing mapping between service string name
-                    and instance of python class representing it
+        @return dictionary containing mapping between service string name
+                and instance of python class representing it
         """
         service_mapping = dict()
         for item in list(service_class_mapping):
-            api_key = self.config.get("SERVICES", self.config).get(item, {}).get("api_key") if self.config else None
+            api_key = self.config.get("SERVICES",
+                                      self.config).get(item,
+                                                       {}).get("api_key") \
+                if self.config else None
             try:
-                service_mapping[item] = service_class_mapping[item](api_key=api_key)
+                service_mapping[item] = \
+                    service_class_mapping[item](api_key=api_key)
             except Exception as e:
                 LOG.error(e)
         return service_mapping
 
     def resolve_query(self, query: dict) -> dict:
         """
-            Generically resolves input query dictionary by mapping its "service" parameter
-            @param query: dictionary with query parameters
-            @return: response from the destination service
+        Generically resolves input query dictionary by mapping its "service"
+        @param query: dictionary with query parameters
+        @return: response from the destination service
         """
         target_service = query.get('service')
         message_id = query.pop('message_id', None)
-        if target_service and target_service in list(self.service_instance_mapping):
-            resp = self.service_instance_mapping[target_service].handle_query(**query)
+        if target_service and target_service in \
+                list(self.service_instance_mapping):
+            resp = self.service_instance_mapping[target_service].\
+                handle_query(**query)
         else:
             resp = {
                 "status_code": 401,
                 "content": f"Unresolved service name: {target_service}",
                 "encoding": "utf-8"
             }
         resp['message_id'] = message_id
```

## neon_api_proxy/owm_api.py

```diff
@@ -23,10 +23,10 @@
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 from neon_api_proxy.services.owm_api import *
-from neon_utils.logger import LOG
+from ovos_utils.log import LOG
 LOG.warning("This reference is deprecated, import from neon_api_proxy.services")
 # TODO: Deprecate in v1.0.0
```

## neon_api_proxy/socket_handler.py

```diff
@@ -23,26 +23,25 @@
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 import socketserver
-import json
-import base64
 
-from neon_utils import LOG
-from neon_utils.socket_utils import *
-from neon_api_proxy.controller import NeonAPIProxyController
+from ovos_utils.log import LOG
+from neon_mq_connector.utils.network_utils import b64_to_dict, dict_to_b64
+from neon_utils.socket_utils import get_packet_data
 
 
 class NeonAPITCPHandler(socketserver.BaseRequestHandler):
-
     def handle(self):
         received_message = get_packet_data(self.request)
         received_message_decoded = b64_to_dict(received_message)
-        LOG.debug(f"Received request from '{self.client_address[0]}' : {received_message_decoded}")
-        response = self.server.controller.resolve_query(received_message_decoded)
+        LOG.debug(f"Received request from '{self.client_address[0]}' : "
+                  f"{received_message_decoded}")
+        response = \
+            self.server.controller.resolve_query(received_message_decoded)
         LOG.debug(f'Received response from controller: {response}')
         encoded_response = dict_to_b64(response)
         LOG.debug(f'Encoded response from controller: {encoded_response}')
         self.request.sendall(encoded_response)
```

## neon_api_proxy/test_api.py

```diff
@@ -23,10 +23,10 @@
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 from neon_api_proxy.services.test_api import *
-from neon_utils.logger import LOG
+from ovos_utils.log import LOG
 LOG.warning("This reference is deprecated, import from neon_api_proxy.services")
 # TODO: Deprecate in v1.0.0
```

## neon_api_proxy/wolfram_api.py

```diff
@@ -23,10 +23,10 @@
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 from neon_api_proxy.services.wolfram_api import *
-from neon_utils.logger import LOG
+from ovos_utils.log import LOG
 LOG.warning("This reference is deprecated, import from neon_api_proxy.services")
 # TODO: Deprecate in v1.0.0
```

## neon_api_proxy/client/__init__.py

```diff
@@ -24,16 +24,16 @@
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 from typing import Optional
 from enum import Enum
-from neon_utils.logger import LOG
-from neon_utils.mq_utils import send_mq_request
+from ovos_utils.log import LOG
+from neon_mq_connector.utils.client_utils import send_mq_request
 
 from neon_api_proxy.controller import NeonAPIProxyController
 
 
 class NeonAPI(Enum):
     def __str__(self):
         return self.value
@@ -48,38 +48,42 @@
 
 class NeonAPIProxyClient(NeonAPIProxyController):
     def __init__(self, auth_config: dict = None):
         super().__init__(auth_config)
 
     def resolve_query(self, query: dict, timeout: int = 30) -> dict:
         target_service = query.get('service')
-        if target_service and target_service in list(self.service_instance_mapping):
+        if target_service and target_service in \
+                list(self.service_instance_mapping):
             LOG.debug(f"Handling API request locally")
             return super().resolve_query(query)
         LOG.debug(f"Forwarding API request to remote")
         return self._request_mq_api(query, timeout)
 
     @staticmethod
     def _request_mq_api(query_params: dict,
                         timeout: int = 30) -> dict:
         """
-            Handle a request for information from the Neon API Proxy Server
-            @param query_params: Data parameters to pass to remote API
-            @param timeout: Request timeout in seconds
-            @return: dict response from API with: `status_code`, `content`, and `encoding`
+        Handle a request for information from the Neon API Proxy Server
+        @param query_params: Data parameters to pass to remote API
+        @param timeout: Request timeout in seconds
+        @return: dict response from API with:
+            `status_code`, `content`, and `encoding`
         """
 
         if not query_params:
             raise ValueError("Got empty query params")
         if not isinstance(query_params, dict):
             raise TypeError(f"Expected dict, got: {query_params}")
 
-        response = send_mq_request("/neon_api", query_params, "neon_api_input", "neon_api_output", timeout)
+        response = send_mq_request("/neon_api", query_params,
+                                   "neon_api_input", "neon_api_output", timeout)
         return response or {"status_code": 401,
-                            "content": f"Neon API failed to give a response within {timeout} seconds",
+                            "content": f"Neon API failed to give a response "
+                                       f"within {timeout} seconds",
                             "encoding": None}
 
 
 _CLIENT: Optional[NeonAPIProxyClient] = None
 
 
 def init_client():
@@ -93,15 +97,16 @@
 
 def request_api(api: NeonAPI, query_params: dict, timeout: int = 30) -> dict:
     """
     Handle an arbitrary API request
     :param api: Service API to target
     :param query_params: Data parameters to pass to service API
     :param timeout: Request timeout in seconds
-    :return: dict response from API with: `status_code`, `content`, and `encoding`
+    :return: dict response from API with:
+    `status_code`, `content`, and `encoding`
     """
 
     if not isinstance(api, NeonAPI):
         raise TypeError(f"Expected a NeonAPI, got: {api}")
     if not query_params:
         raise ValueError("Got empty query params")
     if not isinstance(query_params, dict):
```

## neon_api_proxy/client/alpha_vantage.py

```diff
@@ -25,15 +25,15 @@
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 import json
 
 from json import JSONDecodeError
-from neon_utils.logger import LOG
+from ovos_utils.log import LOG
 from neon_api_proxy.client import NeonAPI, request_api
 
 
 def _get_response_data(resp: dict) -> dict:
     """
     Safely parse the API response data into a dict that can be safely parsed.
     :param resp: dict HTTP response from the API
@@ -66,15 +66,16 @@
     query_params = {**kwargs, **{"api": "symbol", "company": company}}
     resp = request_api(NeonAPI.ALPHA_VANTAGE, query_params)
     data = _get_response_data(resp)
 
     if not data.get("bestMatches"):
         LOG.warning(f"No matches found for {company}")
         return []
-    filtered_data = [stock for stock in data.get("bestMatches") if stock.get("4. region") == region]
+    filtered_data = [stock for stock in data.get("bestMatches") if
+                     stock.get("4. region") == region]
     if not filtered_data:
         filtered_data = data.get("bestMatches")
     data = [{"symbol": stock.get("1. symbol"),
              "name": stock.get("2. name"),
              "region": stock.get("4. region"),
              "currency": stock.get("8. currency")} for stock in filtered_data]
     return data
```

## neon_api_proxy/client/financial_modeling_prep.py

```diff
@@ -22,30 +22,27 @@
 # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-# import json
-#
-# from neon_api_proxy.client import NeonAPI, request_api
-
 
 def search_stock_by_name(company: str, **kwargs) -> list:
     """
     Queries FMP for stocks matching the specified company
     :param company: Company name/stock search term
     :param kwargs:
       'api_key' - optional str api_key to use for query
       'exchange' - optional preferred exchange (default None)
     :return: list of dict matched stock data (`name`, `symbol`)
     """
     raise NotImplementedError("API Not implemented")
-    # resp = query_fmp_api(f"https://financialmodelingprep.com/api/v3/search?{urllib.parse.urlencode(query_params)}")
+    # resp = query_fmp_api(f"https://financialmodelingprep.com/api/v3/search?
+    # {urllib.parse.urlencode(query_params)}")
     # query_params = {**kwargs, **{"api": "symbol",
     #                              "query": company,
     #                              "limit": 10}}
     # resp = request_api(NeonAPI.FINANCIAL_MODELING_PREP, query_params)
     # data = json.loads(resp["content"])
     # return data
 
@@ -55,14 +52,15 @@
     Queries FMP for stock information for the specified company
     :param symbol: Stock ticker symbol
     :param kwargs:
       'api_key' - optional str api_key to use for query
     :return: dict stock data
     """
     raise NotImplementedError("API Not implemented")
-    # resp = query_fmp_api(f"https://financialmodelingprep.com/api/v3/company/profile/{symbol}?"
+    # resp = query_fmp_api(f"https://financialmodelingprep.com/api/v3/
+    # company/profile/{symbol}?"
     #                      f"{urllib.parse.urlencode(query_params)}")
     # query_params = {**kwargs, **{"api": "quote",
     #                              "symbol": symbol}}
     # resp = request_api(NeonAPI.FINANCIAL_MODELING_PREP, query_params)
     # data = json.loads(resp["content"])
     # return data.get("profile")
```

## neon_api_proxy/client/open_weather_map.py

```diff
@@ -26,16 +26,15 @@
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 import json
 from enum import Enum
 from json import JSONDecodeError
 from typing import Union
-from neon_utils.logger import LOG
-
+from ovos_utils.log import LOG
 from neon_api_proxy.client import NeonAPI, request_api
 
 
 class OpenWeatherMapApi(Enum):
     def __repr__(self):
         return self.value
     CURRENT = "weather"
@@ -44,15 +43,15 @@
 
 def get_current_weather(lat: Union[str, float], lng: Union[str, float],
                         units: str = "metric", **kwargs) -> dict:
     """
     Queries Open Weather Map for current weather at the specified location
     :param lat: latitude
     :param lng: longitude
-    :param units: Temperature and Speed units "metric", "imperial", or "standard"
+    :param units: Units of measure "metric", "imperial", or "standard"
     :param kwargs:
       'api_key' - optional str api_key to use for query
       'language' - optional language param (default english)
     :return: dict weather data (https://openweathermap.org/current#current_JSON)
     """
     forecast = _make_api_call(lat, lng, units,
                               OpenWeatherMapApi.CURRENT, **kwargs)
@@ -65,19 +64,20 @@
 
 def get_forecast(lat: Union[str, float], lng: Union[str, float],
                  units: str = "metric", **kwargs) -> dict:
     """
     Queries Open Weather Map for weather data at the specified location
     :param lat: latitude
     :param lng: longitude
-    :param units: Temperature and Speed units "metric", "imperial", or "standard"
+    :param units: Units of measure "metric", "imperial", or "standard"
     :param kwargs:
       'api_key' - optional str api_key to use for query
       'language' - optional language param (default english)
-    :return: dict weather data (https://openweathermap.org/api/one-call-api#hist_example)
+    :return: dict weather data
+        (https://openweathermap.org/api/one-call-api#hist_example)
     """
     return _make_api_call(lat, lng, units, OpenWeatherMapApi.ONECALL, **kwargs)
 
 
 def _make_api_call(lat: Union[str, float], lng: Union[str, float],
                    units: str, target_api: OpenWeatherMapApi,
                    **kwargs) -> dict:
```

## neon_api_proxy/client/wolfram_alpha.py

```diff
@@ -24,33 +24,37 @@
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 from enum import Enum
 from typing import Union
-from neon_utils.net_utils import get_ip_address
-from neon_utils.log_utils import LOG
+from ovos_utils.log import LOG
 from neon_api_proxy.client import NeonAPI, request_api
+from neon_utils.net_utils import get_ip_address
 
 
 class QueryApi(Enum):
     def __repr__(self):
         return self.value
+
     SIMPLE = "simple"
     SHORT = "short"
     SPOKEN = "spoken"
     FULL = "full"
     RECOGNIZE = "recognize"
     CONVERSATION = "conversation"
 
 
-def get_wolfram_alpha_response(query: str, api: QueryApi, units: str = "metric", **kwargs) -> Union[str, bytes]:
+def get_wolfram_alpha_response(query: str, api: QueryApi,
+                               units: str = "metric",
+                               **kwargs) -> Union[str, bytes]:
     """
-    Queries Wolfram|Alpha for a response from the specified API with the specified parameters
+    Queries Wolfram|Alpha for a response from the specified API with the
+        specified parameters
     :param query: Question to submit to Wolfram|Alpha
     :param api: API to target
     :param units: "metric" or "nonmetric" units
     :param kwargs:
       'lat' - optional str latitude
       'lng' - optional str longitude
       'ip' - optional str public IP for geolocation
@@ -86,20 +90,23 @@
     :param api: QueryApi to call
     :return: base URL
     """
     if not api:
         raise ValueError("api is null")
     if not isinstance(api, QueryApi):
         raise TypeError(f"Not a QueryApi: {api}")
-    url_map = {QueryApi.SIMPLE: "http://api.wolframalpha.com/v2/simple",
-               QueryApi.SHORT: "http://api.wolframalpha.com/v2/result",
-               QueryApi.SPOKEN: "http://api.wolframalpha.com/v2/spoken",
-               QueryApi.FULL: "http://api.wolframalpha.com/v2/query",
-               QueryApi.RECOGNIZE: "http://www.wolframalpha.com/queryrecognizer/query.jsp",
-               QueryApi.CONVERSATION: "http://api.wolframalpha.com/v1/conversation.jsp"}
+    url_map = {
+        QueryApi.SIMPLE: "http://api.wolframalpha.com/v2/simple",
+        QueryApi.SHORT: "http://api.wolframalpha.com/v2/result",
+        QueryApi.SPOKEN: "http://api.wolframalpha.com/v2/spoken",
+        QueryApi.FULL: "http://api.wolframalpha.com/v2/query",
+        QueryApi.RECOGNIZE: "http://www.wolframalpha.com/queryrecognizer/"
+                            "query.jsp",
+        QueryApi.CONVERSATION: "http://api.wolframalpha.com/v1/"
+                               "conversation.jsp"}
     return url_map[api]
 
 
 def get_geolocation_params(**kwargs) -> dict:
     """
     Returns a valid dict of data for geolocation (lat/lng or ip)
     :param kwargs:
```

## neon_api_proxy/services/alpha_vantage_api.py

```diff
@@ -26,23 +26,24 @@
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 import urllib.parse
 
 from enum import Enum
 from neon_api_proxy.cached_api import CachedAPI
-# from neon_utils.log_utils import LOG
 from neon_utils.authentication_utils import find_neon_alpha_vantage_key
 
 
 class QueryUrl(Enum):
     def __str__(self):
         return self.value
-    SYMBOL = "https://www.alphavantage.co/query?function=SYMBOL_SEARCH"  # keywords=, apikey=
-    QUOTE = "https://www.alphavantage.co/query?function=GLOBAL_QUOTE"  # symbol=, apikey=
+    SYMBOL = "https://www.alphavantage.co/query?function=SYMBOL_SEARCH"
+    # keywords=, apikey=
+    QUOTE = "https://www.alphavantage.co/query?function=GLOBAL_QUOTE"
+    # symbol=, apikey=
 
 
 class AlphaVantageAPI(CachedAPI):
     """
     API for querying Alpha Vantage.
     """
```

## neon_api_proxy/services/owm_api.py

```diff
@@ -26,15 +26,15 @@
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 import urllib.parse
 from requests import Response
 
 from neon_api_proxy.cached_api import CachedAPI
-from neon_utils.logger import LOG
+from ovos_utils.log import LOG
 from neon_utils.authentication_utils import find_neon_owm_key
 
 
 class OpenWeatherAPI(CachedAPI):
     """
     API for querying Open Weather Map.
     """
@@ -48,15 +48,16 @@
         """
         Handles an incoming query and provides a response
         :param kwargs:
           'lat' - str latitude
           'lng' - str longitude
           'units' - optional string "metric" or "imperial"
           'base_url' - base URL to target
-        :return: dict containing `status_code`, `content`, `encoding` from URL response
+        :return: dict containing `status_code`, `content`, `encoding`
+            from URL response
         """
         lat = kwargs.get("lat")
         lng = kwargs.get("lng", kwargs.get("lon"))
         api = kwargs.get('api') or "onecall"
         units = "metric" if kwargs.get("units") == "metric" else "imperial"
 
         if not all((lat, lng, units)):
```

## neon_api_proxy/services/test_api.py

```diff
@@ -22,31 +22,23 @@
 # EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 # PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 # OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-import urllib.parse
-
-from enum import Enum
-from neon_utils.log_utils import LOG
-from neon_utils.authentication_utils import find_neon_wolfram_key
 from neon_api_proxy.cached_api import CachedAPI
 
 
 class TestAPI(CachedAPI):
-    """
-    API for querying Wolfram|Alpha.
-    """
-
     def __init__(self, api_key: str = None):
         super().__init__("Test")
 
     def handle_query(self, **kwargs) -> dict:
         """
         Handles an incoming query and provides a response
-        :return: dict containing `status_code`, `content`, `encoding` from URL response
+        :return: dict containing `status_code`, `content`, `encoding`
+            from URL response
         """
         return {"status_code": 200,
                 "content": "Success",
                 "encoding": None}
```

## neon_api_proxy/services/wolfram_api.py

```diff
@@ -25,15 +25,15 @@
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE,  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 import urllib.parse
 
 from enum import Enum
-from neon_utils.log_utils import LOG
+from ovos_utils.log import LOG
 from neon_utils.authentication_utils import find_neon_wolfram_key
 from neon_api_proxy.cached_api import CachedAPI
 
 
 class QueryUrl(Enum):
     def __str__(self):
         return self.value
@@ -85,15 +85,16 @@
           'ip' optional string origin IP Address for geolocation
         :return: URL encoded query string used to build a request URL
         """
         if not kwargs.get("query"):
             raise ValueError(f"No query in request: {kwargs}")
         query_params = dict()
         query_params['i'] = kwargs.get("query")
-        query_params['units'] = kwargs.get("units") if kwargs.get("units") == "metric" else "nonmetric"
+        query_params['units'] = kwargs.get("units") if \
+            kwargs.get("units") == "metric" else "nonmetric"
         lat = kwargs.get("lat")
         lng = kwargs.get("lng")
         if kwargs.get("latlong"):
             query_params["latlong"] = kwargs.get("latlong")
         elif lat and lng:
             query_params["latlong"] = f"{lat},{lng}"
         else:
@@ -104,20 +105,22 @@
         return query_str
 
     def handle_query(self, **kwargs) -> dict:
         """
         Handles an incoming query and provides a response
         :param kwargs:
           'query' - string query to ask Wolfram|Alpha
-          'api' - string api to query (simple, short, spoken, full, recognize, conversation)
+          'api' - string api to query
+                (simple, short, spoken, full, recognize, conversation)
           'units' - optional string "metric" or "nonmetric"
           'latlong' - optional string lat/lng
           'lat'+'lng' - optional float or string lat/lng (separate keys)
           'ip' - optional string origin IP Address for geolocation
-        :return: dict containing `status_code`, `content`, `encoding` from URL response
+        :return: dict containing `status_code`, `content`, `encoding`
+            from URL response
         """
         api = kwargs.get("api")
         if not api:
             query_type = QueryUrl.SHORT
         elif api == "simple":
             query_type = QueryUrl.SIMPLE
         elif api == "short":
@@ -141,17 +144,19 @@
         except Exception as e:
             return {"status_code": -1,
                     "content": repr(e),
                     "encoding": None}
 
     def _query_api(self, query: str) -> dict:
         """
-        Queries the Wolfram|Alpha API and returns a dict with the status, content, and encoding
+        Queries the Wolfram|Alpha API and returns a dict with:
+            status, content, and encoding
         :param query: URL to query
-        :return: dict response containing: `status_code`, `content`, and `encoding`
+        :return: dict response containing:
+            `status_code`, `content`, and `encoding`
         """
         result = self.get_with_cache_timeout(query)
         if not result.ok:
             # 501 = Wolfram couldn't understand
             # 403 = Invalid API Key Provided
             LOG.warning(f"API Query error ({result.status_code}): {query}")
         return {"status_code": result.status_code,
```

## Comparing `neon_api_proxy-0.3.3.dist-info/LICENSE.md` & `neon_api_proxy-0.3.4a7.dist-info/LICENSE.md`

 * *Files identical despite different names*

